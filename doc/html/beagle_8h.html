<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BEAGLE: libhmsbeagle/beagle.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beagle-dox.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BEAGLE
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">An Application Programming Interface and High-Performance Computing Library for Statistical Phylogenetics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d98ec6a9a5b94c27cbb90dcc359fa8cf.html">libhmsbeagle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">beagle.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file documents the API as well as header for the Broad-platform Evolutionary Analysis General Likelihood Evaluator.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;libhmsbeagle/platform.h&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for beagle.h:</div>
<div class="dyncontent">
<div class="center"><img src="beagle_8h__incl.png" border="0" usemap="#libhmsbeagle_2beagle_8h" alt=""/></div>
<map name="libhmsbeagle_2beagle_8h" id="libhmsbeagle_2beagle_8h">
</map>
</div>
</div>
<p><a href="beagle_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a specific instance.  <a href="struct_beagle_instance_details.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_resource.html">BeagleResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a hardware resource.  <a href="struct_beagle_resource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of hardware resources.  <a href="struct_beagle_resource_list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_operation.html">BeagleOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of integer indices which specify a partial likelihoods operation.  <a href="struct_beagle_operation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9e61de870cc34893168a88fe6823dfce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">BeagleReturnCodes</a> { <br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea12aea4769c1be89867846782925b1cbe">BEAGLE_SUCCESS</a> = 0, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea45c3bd53fdd83865d927202d0d582299">BEAGLE_ERROR_GENERAL</a> = -1, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaf31bb198b162f0d9ed2e0490a475409d">BEAGLE_ERROR_OUT_OF_MEMORY</a> = -2, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea3fd3b3dc476c527884e6db3dc0d13738">BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION</a> = -3, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaba333086a5777117202ed0f16109157a">BEAGLE_ERROR_UNINITIALIZED_INSTANCE</a> = -4, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea1118b576b6d5e1372f757ec246acd203">BEAGLE_ERROR_OUT_OF_RANGE</a> = -5, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaec9b03ad5cd754a99ed84e1755704beb">BEAGLE_ERROR_NO_RESOURCE</a> = -6, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea74be6f002aba021c7093dfe50b44f1ed">BEAGLE_ERROR_NO_IMPLEMENTATION</a> = -7, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea267dcbe8ced105decc94598ba2be51ba">BEAGLE_ERROR_FLOATING_POINT</a> = -8
<br/>
 }</td></tr>
<tr class="memdesc:a9e61de870cc34893168a88fe6823dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error return codes.  <a href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">More...</a><br/></td></tr>
<tr class="separator:a9e61de870cc34893168a88fe6823dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3abf6b7c463b689a26ec83fb14bdde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">BeagleFlags</a> { <br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea6efa1e464b74cfcf6e7317d79bf1c085">BEAGLE_FLAG_PRECISION_SINGLE</a> = 1 &lt;&lt; 0, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea83963bbb1062fd6c060553de8dd6b429">BEAGLE_FLAG_PRECISION_DOUBLE</a> = 1 &lt;&lt; 1, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac4e28e01f5d95262033f72410ca57c89">BEAGLE_FLAG_COMPUTATION_SYNCH</a> = 1 &lt;&lt; 2, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac2cf9217aa4e7a2e002746528a8ba29b">BEAGLE_FLAG_COMPUTATION_ASYNCH</a> = 1 &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea96ef202a6ec8fc3754dc3095b30a87fb">BEAGLE_FLAG_EIGEN_REAL</a> = 1 &lt;&lt; 4, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea5a64736d6ca8cd54532e35f597671f16">BEAGLE_FLAG_EIGEN_COMPLEX</a> = 1 &lt;&lt; 5, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea44746eb12a08bd5427ecf7e0508e02e9">BEAGLE_FLAG_SCALING_MANUAL</a> = 1 &lt;&lt; 6, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea78667e7bb79ac6c002d0180d3e27d6b5">BEAGLE_FLAG_SCALING_AUTO</a> = 1 &lt;&lt; 7, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea11d8bbb56c0d104bf29e877f90f12935">BEAGLE_FLAG_SCALING_ALWAYS</a> = 1 &lt;&lt; 8, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea8c750c64eb7c532c40a1b520c7253656">BEAGLE_FLAG_SCALING_DYNAMIC</a> = 1 &lt;&lt; 25, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea81574eae3cca4fd42b3b34d731555b64">BEAGLE_FLAG_SCALERS_RAW</a> = 1 &lt;&lt; 9, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea90091808850e51109fcb2f06fc8eb6f3">BEAGLE_FLAG_SCALERS_LOG</a> = 1 &lt;&lt; 10, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeadbd1b3e83d25b5fae3a14a724b24cec2">BEAGLE_FLAG_INVEVEC_STANDARD</a> = 1 &lt;&lt; 20, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9fc181aac842ebac6d51ccb19cf0e2ca">BEAGLE_FLAG_INVEVEC_TRANSPOSED</a> = 1 &lt;&lt; 21, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea6f9a787ae342115c27a7437e8b0d9dc6">BEAGLE_FLAG_VECTOR_SSE</a> = 1 &lt;&lt; 11, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeab55cd0f09a8c91e5d2d51b239515da4a">BEAGLE_FLAG_VECTOR_AVX</a> = 1 &lt;&lt; 24, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea538654597350cea65553c70189ceb107">BEAGLE_FLAG_VECTOR_NONE</a> = 1 &lt;&lt; 12, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac522542d33f45928656aa2dfe478b3ce">BEAGLE_FLAG_THREADING_OPENMP</a> = 1 &lt;&lt; 13, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea444ce15e77f6cfaeb77ee1762925cd77">BEAGLE_FLAG_THREADING_NONE</a> = 1 &lt;&lt; 14, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9aea9b1db1765a059e5f0c994c7ff5b4">BEAGLE_FLAG_PROCESSOR_CPU</a> = 1 &lt;&lt; 15, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeaf7a580b8584fbdba42c5a1bab2b6ed6c">BEAGLE_FLAG_PROCESSOR_GPU</a> = 1 &lt;&lt; 16, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9480c27a220b39df8980176376e27bbf">BEAGLE_FLAG_PROCESSOR_FPGA</a> = 1 &lt;&lt; 17, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea5dcb70fa15d216e8295982953d535ff9">BEAGLE_FLAG_PROCESSOR_CELL</a> = 1 &lt;&lt; 18, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeaad2f12434a5b2882925c836976cf49cc">BEAGLE_FLAG_PROCESSOR_PHI</a> = 1 &lt;&lt; 19, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea3e2ddc258bd1d83c75bbeff3f57c94d8">BEAGLE_FLAG_PROCESSOR_OTHER</a> = 1 &lt;&lt; 26, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea40c7b4711118fb6fa14e697a698eda87">BEAGLE_FLAG_FRAMEWORK_CUDA</a> = 1 &lt;&lt; 22, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea04dcbc29ff83699be424c21b38e57d06">BEAGLE_FLAG_FRAMEWORK_OPENCL</a> = 1 &lt;&lt; 23, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeacc951e8ceb79f83b91977b2cea646917">BEAGLE_FLAG_FRAMEWORK_CPU</a> = 1 &lt;&lt; 27
<br/>
 }</td></tr>
<tr class="memdesc:a3f3abf6b7c463b689a26ec83fb14bdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware and implementation capability flags.  <a href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">More...</a><br/></td></tr>
<tr class="separator:a3f3abf6b7c463b689a26ec83fb14bdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487a1c99f4214cd3a70468d0ccac55c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">BeagleOpCodes</a> { <a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55ca907d2c6aac07be265a496476a55216e5">BEAGLE_OP_COUNT</a> = 7, 
<a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55ca2eb262bbe41b1dbeff3e189d8de65b04">BEAGLE_OP_NONE</a> = -1
 }</td></tr>
<tr class="memdesc:a2487a1c99f4214cd3a70468d0ccac55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation codes.  <a href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">More...</a><br/></td></tr>
<tr class="separator:a2487a1c99f4214cd3a70468d0ccac55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7548767f2cb3af22eeaec53033b826e7"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a7548767f2cb3af22eeaec53033b826e7">beagleGetVersion</a> (void)</td></tr>
<tr class="memdesc:a7548767f2cb3af22eeaec53033b826e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version.  <a href="#a7548767f2cb3af22eeaec53033b826e7">More...</a><br/></td></tr>
<tr class="separator:a7548767f2cb3af22eeaec53033b826e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057301859e993ba24d5b9fdc7f7ecd8"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aa057301859e993ba24d5b9fdc7f7ecd8">beagleGetCitation</a> (void)</td></tr>
<tr class="memdesc:aa057301859e993ba24d5b9fdc7f7ecd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get citation.  <a href="#aa057301859e993ba24d5b9fdc7f7ecd8">More...</a><br/></td></tr>
<tr class="separator:aa057301859e993ba24d5b9fdc7f7ecd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389ba7c4a2e4ec083fada4b43d15df16"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT <br class="typebreak"/>
<a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a389ba7c4a2e4ec083fada4b43d15df16">beagleGetResourceList</a> (void)</td></tr>
<tr class="memdesc:a389ba7c4a2e4ec083fada4b43d15df16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of hardware resources.  <a href="#a389ba7c4a2e4ec083fada4b43d15df16">More...</a><br/></td></tr>
<tr class="separator:a389ba7c4a2e4ec083fada4b43d15df16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbfa8c48d0cd2dbc8f253a51f5b777e"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a8bbfa8c48d0cd2dbc8f253a51f5b777e">beagleCreateInstance</a> (int tipCount, int partialsBufferCount, int compactBufferCount, int stateCount, int patternCount, int eigenBufferCount, int matrixBufferCount, int categoryCount, int scaleBufferCount, int *resourceList, int resourceCount, long preferenceFlags, long requirementFlags, <a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a> *returnInfo)</td></tr>
<tr class="memdesc:a8bbfa8c48d0cd2dbc8f253a51f5b777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a single instance.  <a href="#a8bbfa8c48d0cd2dbc8f253a51f5b777e">More...</a><br/></td></tr>
<tr class="separator:a8bbfa8c48d0cd2dbc8f253a51f5b777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35df026165d96afb3a09079126666dc"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aa35df026165d96afb3a09079126666dc">beagleFinalizeInstance</a> (int instance)</td></tr>
<tr class="memdesc:aa35df026165d96afb3a09079126666dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize this instance.  <a href="#aa35df026165d96afb3a09079126666dc">More...</a><br/></td></tr>
<tr class="separator:aa35df026165d96afb3a09079126666dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d6a18112618e6e4955d7f7dc22617"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a7c5d6a18112618e6e4955d7f7dc22617">beagleFinalize</a> (void)</td></tr>
<tr class="memdesc:a7c5d6a18112618e6e4955d7f7dc22617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the library.  <a href="#a7c5d6a18112618e6e4955d7f7dc22617">More...</a><br/></td></tr>
<tr class="separator:a7c5d6a18112618e6e4955d7f7dc22617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248ac2d4e93da19d4598a488545beb3a"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a248ac2d4e93da19d4598a488545beb3a">beagleSetTipStates</a> (int instance, int tipIndex, const int *inStates)</td></tr>
<tr class="memdesc:a248ac2d4e93da19d4598a488545beb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the compact state representation for tip node.  <a href="#a248ac2d4e93da19d4598a488545beb3a">More...</a><br/></td></tr>
<tr class="separator:a248ac2d4e93da19d4598a488545beb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da6fcc385325ac71c0268ba49c91735"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a8da6fcc385325ac71c0268ba49c91735">beagleSetTipPartials</a> (int instance, int tipIndex, const double *inPartials)</td></tr>
<tr class="memdesc:a8da6fcc385325ac71c0268ba49c91735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an instance partials buffer for tip node.  <a href="#a8da6fcc385325ac71c0268ba49c91735">More...</a><br/></td></tr>
<tr class="separator:a8da6fcc385325ac71c0268ba49c91735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9587451dddf791c2b28de95b91a8aa"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a4d9587451dddf791c2b28de95b91a8aa">beagleSetPartials</a> (int instance, int bufferIndex, const double *inPartials)</td></tr>
<tr class="memdesc:a4d9587451dddf791c2b28de95b91a8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an instance partials buffer.  <a href="#a4d9587451dddf791c2b28de95b91a8aa">More...</a><br/></td></tr>
<tr class="separator:a4d9587451dddf791c2b28de95b91a8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f698c0acaf059732079e854682ab8bb"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a6f698c0acaf059732079e854682ab8bb">beagleGetPartials</a> (int instance, int bufferIndex, int scaleIndex, double *outPartials)</td></tr>
<tr class="memdesc:a6f698c0acaf059732079e854682ab8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partials from an instance buffer.  <a href="#a6f698c0acaf059732079e854682ab8bb">More...</a><br/></td></tr>
<tr class="separator:a6f698c0acaf059732079e854682ab8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae27b7b658d2a30a520190915ac10ae3"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aae27b7b658d2a30a520190915ac10ae3">beagleSetEigenDecomposition</a> (int instance, int eigenIndex, const double *inEigenVectors, const double *inInverseEigenVectors, const double *inEigenValues)</td></tr>
<tr class="memdesc:aae27b7b658d2a30a520190915ac10ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an eigen-decomposition buffer.  <a href="#aae27b7b658d2a30a520190915ac10ae3">More...</a><br/></td></tr>
<tr class="separator:aae27b7b658d2a30a520190915ac10ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8f0f07b5510150efe1b72df2270f4d"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aed8f0f07b5510150efe1b72df2270f4d">beagleSetStateFrequencies</a> (int instance, int stateFrequenciesIndex, const double *inStateFrequencies)</td></tr>
<tr class="memdesc:aed8f0f07b5510150efe1b72df2270f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a state frequency buffer.  <a href="#aed8f0f07b5510150efe1b72df2270f4d">More...</a><br/></td></tr>
<tr class="separator:aed8f0f07b5510150efe1b72df2270f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e162e36113dfd5edb1dc57c2e99e3b5"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a9e162e36113dfd5edb1dc57c2e99e3b5">beagleSetCategoryWeights</a> (int instance, int categoryWeightsIndex, const double *inCategoryWeights)</td></tr>
<tr class="memdesc:a9e162e36113dfd5edb1dc57c2e99e3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a category weights buffer.  <a href="#a9e162e36113dfd5edb1dc57c2e99e3b5">More...</a><br/></td></tr>
<tr class="separator:a9e162e36113dfd5edb1dc57c2e99e3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a18af42b3eb11d1d7dc8c86204ce8"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a404a18af42b3eb11d1d7dc8c86204ce8">beagleSetCategoryRates</a> (int instance, const double *inCategoryRates)</td></tr>
<tr class="memdesc:a404a18af42b3eb11d1d7dc8c86204ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set category rates.  <a href="#a404a18af42b3eb11d1d7dc8c86204ce8">More...</a><br/></td></tr>
<tr class="separator:a404a18af42b3eb11d1d7dc8c86204ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbfc9e38a2dd362b0f03f29cab42ac6"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aebbfc9e38a2dd362b0f03f29cab42ac6">beagleSetPatternWeights</a> (int instance, const double *inPatternWeights)</td></tr>
<tr class="memdesc:aebbfc9e38a2dd362b0f03f29cab42ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pattern weights.  <a href="#aebbfc9e38a2dd362b0f03f29cab42ac6">More...</a><br/></td></tr>
<tr class="separator:aebbfc9e38a2dd362b0f03f29cab42ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aff3cb6241e9fe59a0cb5c5cc29ee0"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a50aff3cb6241e9fe59a0cb5c5cc29ee0">beagleConvolveTransitionMatrices</a> (int instance, const int *firstIndices, const int *secondIndices, const int *resultIndices, int matrixCount)</td></tr>
<tr class="memdesc:a50aff3cb6241e9fe59a0cb5c5cc29ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve lists of transition probability matrices.  <a href="#a50aff3cb6241e9fe59a0cb5c5cc29ee0">More...</a><br/></td></tr>
<tr class="separator:a50aff3cb6241e9fe59a0cb5c5cc29ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5528ac9d57faaa14947260a297496269"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a5528ac9d57faaa14947260a297496269">beagleUpdateTransitionMatrices</a> (int instance, int eigenIndex, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const double *edgeLengths, int count)</td></tr>
<tr class="memdesc:a5528ac9d57faaa14947260a297496269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a list of transition probability matrices.  <a href="#a5528ac9d57faaa14947260a297496269">More...</a><br/></td></tr>
<tr class="separator:a5528ac9d57faaa14947260a297496269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac209b67480022546bed413034bf771a0"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ac209b67480022546bed413034bf771a0">beagleSetTransitionMatrix</a> (int instance, int matrixIndex, const double *inMatrix, double paddedValue)</td></tr>
<tr class="memdesc:ac209b67480022546bed413034bf771a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a finite-time transition probability matrix.  <a href="#ac209b67480022546bed413034bf771a0">More...</a><br/></td></tr>
<tr class="separator:ac209b67480022546bed413034bf771a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4054c89db17dd5cc50c0f1c077bee8c8"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a4054c89db17dd5cc50c0f1c077bee8c8">beagleGetTransitionMatrix</a> (int instance, int matrixIndex, double *outMatrix)</td></tr>
<tr class="memdesc:a4054c89db17dd5cc50c0f1c077bee8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a finite-time transition probability matrix.  <a href="#a4054c89db17dd5cc50c0f1c077bee8c8">More...</a><br/></td></tr>
<tr class="separator:a4054c89db17dd5cc50c0f1c077bee8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c7aac15b0cc06f03e6177ad0a161e6"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a72c7aac15b0cc06f03e6177ad0a161e6">beagleSetTransitionMatrices</a> (int instance, const int *matrixIndices, const double *inMatrices, const double *paddedValues, int count)</td></tr>
<tr class="memdesc:a72c7aac15b0cc06f03e6177ad0a161e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple transition matrices.  <a href="#a72c7aac15b0cc06f03e6177ad0a161e6">More...</a><br/></td></tr>
<tr class="separator:a72c7aac15b0cc06f03e6177ad0a161e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6335b5efc17f331282daec82e94226"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a1c6335b5efc17f331282daec82e94226">beagleUpdatePartials</a> (const int instance, const <a class="el" href="struct_beagle_operation.html">BeagleOperation</a> *operations, int operationCount, int cumulativeScaleIndex)</td></tr>
<tr class="memdesc:a1c6335b5efc17f331282daec82e94226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate or queue for calculation partials using a list of operations.  <a href="#a1c6335b5efc17f331282daec82e94226">More...</a><br/></td></tr>
<tr class="separator:a1c6335b5efc17f331282daec82e94226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34345b9feb1a92a9ed247dbb93192b4"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ab34345b9feb1a92a9ed247dbb93192b4">beagleWaitForPartials</a> (const int instance, const int *destinationPartials, int destinationPartialsCount)</td></tr>
<tr class="memdesc:ab34345b9feb1a92a9ed247dbb93192b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all calculations that write to the specified partials have completed.  <a href="#ab34345b9feb1a92a9ed247dbb93192b4">More...</a><br/></td></tr>
<tr class="separator:ab34345b9feb1a92a9ed247dbb93192b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ba5ba75cda49363b82f48def77847"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aea0ba5ba75cda49363b82f48def77847">beagleAccumulateScaleFactors</a> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</td></tr>
<tr class="memdesc:aea0ba5ba75cda49363b82f48def77847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate scale factors.  <a href="#aea0ba5ba75cda49363b82f48def77847">More...</a><br/></td></tr>
<tr class="separator:aea0ba5ba75cda49363b82f48def77847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0703dedf208d98a4b86ea8ee0b2e358d"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a0703dedf208d98a4b86ea8ee0b2e358d">beagleRemoveScaleFactors</a> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</td></tr>
<tr class="memdesc:a0703dedf208d98a4b86ea8ee0b2e358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove scale factors.  <a href="#a0703dedf208d98a4b86ea8ee0b2e358d">More...</a><br/></td></tr>
<tr class="separator:a0703dedf208d98a4b86ea8ee0b2e358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b1d6509865e06715cf96b7f5ec0b13"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ad0b1d6509865e06715cf96b7f5ec0b13">beagleResetScaleFactors</a> (int instance, int cumulativeScaleIndex)</td></tr>
<tr class="memdesc:ad0b1d6509865e06715cf96b7f5ec0b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset scalefactors.  <a href="#ad0b1d6509865e06715cf96b7f5ec0b13">More...</a><br/></td></tr>
<tr class="separator:ad0b1d6509865e06715cf96b7f5ec0b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c460f21b89acb0ad551be0d9143133"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a66c460f21b89acb0ad551be0d9143133">beagleCopyScaleFactors</a> (int instance, int destScalingIndex, int srcScalingIndex)</td></tr>
<tr class="memdesc:a66c460f21b89acb0ad551be0d9143133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy scale factors.  <a href="#a66c460f21b89acb0ad551be0d9143133">More...</a><br/></td></tr>
<tr class="separator:a66c460f21b89acb0ad551be0d9143133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f3d7704eb53e34b091b86a7e9baee"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a967f3d7704eb53e34b091b86a7e9baee">beagleCalculateRootLogLikelihoods</a> (int instance, const int *bufferIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood)</td></tr>
<tr class="memdesc:a967f3d7704eb53e34b091b86a7e9baee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate site log likelihoods at a root node.  <a href="#a967f3d7704eb53e34b091b86a7e9baee">More...</a><br/></td></tr>
<tr class="separator:a967f3d7704eb53e34b091b86a7e9baee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1622661032ea7959e985592d86a9fa77"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a1622661032ea7959e985592d86a9fa77">beagleCalculateEdgeLogLikelihoods</a> (int instance, const int *parentBufferIndices, const int *childBufferIndices, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood, double *outSumFirstDerivative, double *outSumSecondDerivative)</td></tr>
<tr class="memdesc:a1622661032ea7959e985592d86a9fa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate site log likelihoods and derivatives along an edge.  <a href="#a1622661032ea7959e985592d86a9fa77">More...</a><br/></td></tr>
<tr class="separator:a1622661032ea7959e985592d86a9fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7a453b2d4a89be02f75f8e9ae9ab9"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a8de7a453b2d4a89be02f75f8e9ae9ab9">beagleGetSiteLogLikelihoods</a> (int instance, double *outLogLikelihoods)</td></tr>
<tr class="memdesc:a8de7a453b2d4a89be02f75f8e9ae9ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call.  <a href="#a8de7a453b2d4a89be02f75f8e9ae9ab9">More...</a><br/></td></tr>
<tr class="separator:a8de7a453b2d4a89be02f75f8e9ae9ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd7856124724dc18058935d8aaa08ec"><td class="memItemLeft" align="right" valign="top">BEAGLE_DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a7bd7856124724dc18058935d8aaa08ec">beagleGetSiteDerivatives</a> (int instance, double *outFirstDerivatives, double *outSecondDerivatives)</td></tr>
<tr class="memdesc:a7bd7856124724dc18058935d8aaa08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get site derivatives for last beagleCalculateEdgeLogLikelihoods call.  <a href="#a7bd7856124724dc18058935d8aaa08ec">More...</a><br/></td></tr>
<tr class="separator:a7bd7856124724dc18058935d8aaa08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file documents the API as well as header for the Broad-platform Evolutionary Analysis General Likelihood Evaluator. </p>
<p>Copyright 2009-2013 Phylogenetic Likelihood Working Group</p>
<p>This file is part of BEAGLE.</p>
<p>BEAGLE is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>BEAGLE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with BEAGLE. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<p>KEY CONCEPTS</p>
<p>The key to BEAGLE performance lies in delivering fine-scale parallelization while minimizing data transfer and memory copy overhead. To accomplish this, the library lacks the concept of data structure for a tree, in spite of the intended use for phylogenetic analysis. Instead, BEAGLE acts directly on flexibly indexed data storage (called buffers) for observed character states and partial likelihoods. The client program can set the input buffers to reflect the data and can calculate the likelihood of a particular phylogeny by invoking likelihood calculations on the appropriate input and output buffers in the correct order. Because of this design simplicity, the library can support many different tree inference algorithms and likelihood calculation on a variety of models. Arbitrary numbers of states can be used, as can nonreversible substitution matrices via complex eigen decompositions, and mixture models with multiple rate categories and/or multiple eigen decompositions. Finally, BEAGLE application programming interface (API) calls can be asynchronous, allowing the calling program to implement other coarse-scale parallelization schemes such as evaluating independent genes or running concurrent Markov chains.</p>
<p>USAGE</p>
<p>To use the library, a client program first creates an instance of BEAGLE by calling beagleCreateInstance; multiple instances per client are possible and encouraged. All additional functions are called with a reference to this instance. The client program can optionally request that an instance run on certain hardware (e.g., a GPU) or have particular features (e.g., double-precision math). Next, the client program must specify the data dimensions and specify key aspects of the phylogenetic model. Character state data are then loaded and can be in the form of discrete observed states or partial likelihoods for ambiguous characters. The observed data are usually unchanging and loaded only once at the start to minimize memory copy overhead. The character data can be compressed into unique “site patterns” and associated weights for each. The parameters of the substitution process can then be specified, including the equilibrium state frequencies, the rates for one or more substitution rate categories and their weights, and finally, the eigen decomposition for the substitution process.</p>
<p>In order to calculate the likelihood of a particular tree, the client program then specifies a series of integration operations that correspond to steps in Felsenstein’s algorithm. Finite-time transition probabilities for each edge are loaded directly if considering a nondiagonalizable model or calculated in parallel from the eigen decomposition and edge lengths specified. This is performed within BEAGLE’s memory space to minimize data transfers. A single function call will then request one or more integration operations to calculate partial likelihoods over some or all nodes. The operations are performed in the order they are provided, typically dictated by a postorder traversal of the tree topology. The client needs only specify nodes for which the partial likelihoods need updating, but it is up to the calling software to keep track of these dependencies. The final step in evaluating the phylogenetic model is done using an API call that yields a single log likelihood for the model given the data.</p>
<p>Aspects of the BEAGLE API design support both maximum likelihood (ML) and Bayesian phylogenetic tree inference. For ML inference, API calls can calculate first and second derivatives of the likelihood with respect to the lengths of edges (branches). In both cases, BEAGLE provides the ability to cache and reuse previously computed partial likelihood results, which can yield a tremendous speedup over recomputing the entire likelihood every time a new phylogenetic model is evaluated.</p>
<dl class="section author"><dt>Author</dt><dd>Likelihood API Working Group</dd>
<dd>
Daniel Ayres </dd>
<dd>
Peter Beerli </dd>
<dd>
Michael Cummings </dd>
<dd>
Aaron Darling </dd>
<dd>
Mark Holder </dd>
<dd>
John Huelsenbeck </dd>
<dd>
Paul Lewis </dd>
<dd>
Michael Ott </dd>
<dd>
Andrew Rambaut </dd>
<dd>
Fredrik Ronquist </dd>
<dd>
Marc Suchard </dd>
<dd>
David Swofford </dd>
<dd>
Derrick Zwickl </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bdde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">BeagleFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware and implementation capability flags. </p>
<p><a class="anchor" id="BEAGLE_FLAGS"></a> This enumerates all possible hardware and implementation capability flags. Each capability is a bit in a 'long' </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea6efa1e464b74cfcf6e7317d79bf1c085"></a>BEAGLE_FLAG_PRECISION_SINGLE</em>&nbsp;</td><td class="fielddoc">
<p>Single precision computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea83963bbb1062fd6c060553de8dd6b429"></a>BEAGLE_FLAG_PRECISION_DOUBLE</em>&nbsp;</td><td class="fielddoc">
<p>Double precision computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac4e28e01f5d95262033f72410ca57c89"></a>BEAGLE_FLAG_COMPUTATION_SYNCH</em>&nbsp;</td><td class="fielddoc">
<p>Synchronous computation (blocking) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac2cf9217aa4e7a2e002746528a8ba29b"></a>BEAGLE_FLAG_COMPUTATION_ASYNCH</em>&nbsp;</td><td class="fielddoc">
<p>Asynchronous computation (non-blocking) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea96ef202a6ec8fc3754dc3095b30a87fb"></a>BEAGLE_FLAG_EIGEN_REAL</em>&nbsp;</td><td class="fielddoc">
<p>Real eigenvalue computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea5a64736d6ca8cd54532e35f597671f16"></a>BEAGLE_FLAG_EIGEN_COMPLEX</em>&nbsp;</td><td class="fielddoc">
<p>Complex eigenvalue computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea44746eb12a08bd5427ecf7e0508e02e9"></a>BEAGLE_FLAG_SCALING_MANUAL</em>&nbsp;</td><td class="fielddoc">
<p>Manual scaling </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea78667e7bb79ac6c002d0180d3e27d6b5"></a>BEAGLE_FLAG_SCALING_AUTO</em>&nbsp;</td><td class="fielddoc">
<p>Auto-scaling on </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea11d8bbb56c0d104bf29e877f90f12935"></a>BEAGLE_FLAG_SCALING_ALWAYS</em>&nbsp;</td><td class="fielddoc">
<p>Scale at every updatePartials </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea8c750c64eb7c532c40a1b520c7253656"></a>BEAGLE_FLAG_SCALING_DYNAMIC</em>&nbsp;</td><td class="fielddoc">
<p>Manual scaling with dynamic checking </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea81574eae3cca4fd42b3b34d731555b64"></a>BEAGLE_FLAG_SCALERS_RAW</em>&nbsp;</td><td class="fielddoc">
<p>Save raw scalers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea90091808850e51109fcb2f06fc8eb6f3"></a>BEAGLE_FLAG_SCALERS_LOG</em>&nbsp;</td><td class="fielddoc">
<p>Save log scalers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeadbd1b3e83d25b5fae3a14a724b24cec2"></a>BEAGLE_FLAG_INVEVEC_STANDARD</em>&nbsp;</td><td class="fielddoc">
<p>Inverse eigen vectors passed to BEAGLE have not been transposed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9fc181aac842ebac6d51ccb19cf0e2ca"></a>BEAGLE_FLAG_INVEVEC_TRANSPOSED</em>&nbsp;</td><td class="fielddoc">
<p>Inverse eigen vectors passed to BEAGLE have been transposed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea6f9a787ae342115c27a7437e8b0d9dc6"></a>BEAGLE_FLAG_VECTOR_SSE</em>&nbsp;</td><td class="fielddoc">
<p>SSE computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeab55cd0f09a8c91e5d2d51b239515da4a"></a>BEAGLE_FLAG_VECTOR_AVX</em>&nbsp;</td><td class="fielddoc">
<p>AVX computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea538654597350cea65553c70189ceb107"></a>BEAGLE_FLAG_VECTOR_NONE</em>&nbsp;</td><td class="fielddoc">
<p>No vector computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac522542d33f45928656aa2dfe478b3ce"></a>BEAGLE_FLAG_THREADING_OPENMP</em>&nbsp;</td><td class="fielddoc">
<p>OpenMP threading </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea444ce15e77f6cfaeb77ee1762925cd77"></a>BEAGLE_FLAG_THREADING_NONE</em>&nbsp;</td><td class="fielddoc">
<p>No threading </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9aea9b1db1765a059e5f0c994c7ff5b4"></a>BEAGLE_FLAG_PROCESSOR_CPU</em>&nbsp;</td><td class="fielddoc">
<p>Use CPU as main processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeaf7a580b8584fbdba42c5a1bab2b6ed6c"></a>BEAGLE_FLAG_PROCESSOR_GPU</em>&nbsp;</td><td class="fielddoc">
<p>Use GPU as main processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9480c27a220b39df8980176376e27bbf"></a>BEAGLE_FLAG_PROCESSOR_FPGA</em>&nbsp;</td><td class="fielddoc">
<p>Use FPGA as main processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea5dcb70fa15d216e8295982953d535ff9"></a>BEAGLE_FLAG_PROCESSOR_CELL</em>&nbsp;</td><td class="fielddoc">
<p>Use Cell as main processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeaad2f12434a5b2882925c836976cf49cc"></a>BEAGLE_FLAG_PROCESSOR_PHI</em>&nbsp;</td><td class="fielddoc">
<p>Use Intel Phi as main processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea3e2ddc258bd1d83c75bbeff3f57c94d8"></a>BEAGLE_FLAG_PROCESSOR_OTHER</em>&nbsp;</td><td class="fielddoc">
<p>Use other type of processor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea40c7b4711118fb6fa14e697a698eda87"></a>BEAGLE_FLAG_FRAMEWORK_CUDA</em>&nbsp;</td><td class="fielddoc">
<p>Use CUDA implementation with GPU resources </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea04dcbc29ff83699be424c21b38e57d06"></a>BEAGLE_FLAG_FRAMEWORK_OPENCL</em>&nbsp;</td><td class="fielddoc">
<p>Use OpenCL implementation with GPU resources </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeacc951e8ceb79f83b91977b2cea646917"></a>BEAGLE_FLAG_FRAMEWORK_CPU</em>&nbsp;</td><td class="fielddoc">
<p>Use CPU implementation </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">BeagleOpCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation codes. </p>
<p><a class="anchor" id="BEAGLE_OP_CODES"></a> This enumerates all possible BEAGLE operation codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55ca907d2c6aac07be265a496476a55216e5"></a>BEAGLE_OP_COUNT</em>&nbsp;</td><td class="fielddoc">
<p>Total number of integers per beagleUpdatePartials operation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55ca2eb262bbe41b1dbeff3e189d8de65b04"></a>BEAGLE_OP_NONE</em>&nbsp;</td><td class="fielddoc">
<p>Specify no use for indexed buffer </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9e61de870cc34893168a88fe6823dfce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">BeagleReturnCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error return codes. </p>
<p><a class="anchor" id="BEAGLE_RETURN_CODES"></a> This enumerates all possible BEAGLE return codes. Error codes are always negative. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea12aea4769c1be89867846782925b1cbe"></a>BEAGLE_SUCCESS</em>&nbsp;</td><td class="fielddoc">
<p>Success </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea45c3bd53fdd83865d927202d0d582299"></a>BEAGLE_ERROR_GENERAL</em>&nbsp;</td><td class="fielddoc">
<p>Unspecified error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaf31bb198b162f0d9ed2e0490a475409d"></a>BEAGLE_ERROR_OUT_OF_MEMORY</em>&nbsp;</td><td class="fielddoc">
<p>Not enough memory could be allocated </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea3fd3b3dc476c527884e6db3dc0d13738"></a>BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION</em>&nbsp;</td><td class="fielddoc">
<p>Unspecified exception </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaba333086a5777117202ed0f16109157a"></a>BEAGLE_ERROR_UNINITIALIZED_INSTANCE</em>&nbsp;</td><td class="fielddoc">
<p>The instance index is out of range, or the instance has not been created </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea1118b576b6d5e1372f757ec246acd203"></a>BEAGLE_ERROR_OUT_OF_RANGE</em>&nbsp;</td><td class="fielddoc">
<p>One of the indices specified exceeded the range of the array </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaec9b03ad5cd754a99ed84e1755704beb"></a>BEAGLE_ERROR_NO_RESOURCE</em>&nbsp;</td><td class="fielddoc">
<p>No resource matches requirements </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea74be6f002aba021c7093dfe50b44f1ed"></a>BEAGLE_ERROR_NO_IMPLEMENTATION</em>&nbsp;</td><td class="fielddoc">
<p>No implementation matches requirements </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea267dcbe8ced105decc94598ba2be51ba"></a>BEAGLE_ERROR_FLOATING_POINT</em>&nbsp;</td><td class="fielddoc">
<p>Floating-point range exceeded </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aea0ba5ba75cda49363b82f48def77847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleAccumulateScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>scaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate scale factors. </p>
<p>This function adds (log) scale factors from a list of scaleBuffers to a cumulative scale buffer. It is used to calculate the marginal scaling at a specific node for each site.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">scaleIndices</td><td>List of scaleBuffers to add (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of scaleBuffers in list (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer to accumulate factors into (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1622661032ea7959e985592d86a9fa77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleCalculateEdgeLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>parentBufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>childBufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>probabilityIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>categoryWeightsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumLogLikelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumFirstDerivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumSecondDerivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate site log likelihoods and derivatives along an edge. </p>
<p>This function integrates a list of partials at a parent and child node with respect to a set of partials-weights and state frequencies to return the log likelihood and first and second derivative sums</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">parentBufferIndices</td><td>List of indices of parent partialsBuffers (input) </td></tr>
    <tr><td class="paramname">childBufferIndices</td><td>List of indices of child partialsBuffers (input) </td></tr>
    <tr><td class="paramname">probabilityIndices</td><td>List indices of transition probability matrices for this edge (input) </td></tr>
    <tr><td class="paramname">firstDerivativeIndices</td><td>List indices of first derivative matrices (input) </td></tr>
    <tr><td class="paramname">secondDerivativeIndices</td><td>List indices of second derivative matrices (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndices</td><td>List of weights to apply to each partialsBuffer (input) </td></tr>
    <tr><td class="paramname">stateFrequenciesIndices</td><td>List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">cumulativeScaleIndices</td><td>List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">count</td><td>Number of partialsBuffers (input) </td></tr>
    <tr><td class="paramname">outSumLogLikelihood</td><td>Pointer to destination for resulting log likelihood (output) </td></tr>
    <tr><td class="paramname">outSumFirstDerivative</td><td>Pointer to destination for resulting first derivative (output) </td></tr>
    <tr><td class="paramname">outSumSecondDerivative</td><td>Pointer to destination for resulting second derivative (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a967f3d7704eb53e34b091b86a7e9baee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleCalculateRootLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>bufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>categoryWeightsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumLogLikelihood</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate site log likelihoods at a root node. </p>
<p>This function integrates a list of partials at a node with respect to a set of partials-weights and state frequencies to return the log likelihood sum</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">bufferIndices</td><td>List of partialsBuffer indices to integrate (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndices</td><td>List of weights to apply to each partialsBuffer (input). There should be one categoryCount sized set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">stateFrequenciesIndices</td><td>List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">cumulativeScaleIndices</td><td>List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">count</td><td>Number of partialsBuffer to integrate (input) </td></tr>
    <tr><td class="paramname">outSumLogLikelihood</td><td>Pointer to destination for resulting log likelihood (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a50aff3cb6241e9fe59a0cb5c5cc29ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleConvolveTransitionMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve lists of transition probability matrices. </p>
<p>This function convolves two lists of transition probability matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">firstIndices</td><td>List of indices of the first transition probability matrices to convolve (input) </td></tr>
    <tr><td class="paramname">secondIndices</td><td>List of indices of the second transition probability matrices to convolve (input) </td></tr>
    <tr><td class="paramname">resultIndices</td><td>List of indices of resulting transition probability matrices (input) </td></tr>
    <tr><td class="paramname">matrixCount</td><td>Length of lists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66c460f21b89acb0ad551be0d9143133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleCopyScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destScalingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcScalingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy scale factors. </p>
<p>This function copies scale factors from one buffer to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">destScalingIndex</td><td>Destination scaleBuffer (input) </td></tr>
    <tr><td class="paramname">srcScalingIndex</td><td>Source scaleBuffer (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bbfa8c48d0cd2dbc8f253a51f5b777e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleCreateInstance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partialsBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compactBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stateCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>categoryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resourceList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resourceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>preferenceFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>requirementFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a> *&#160;</td>
          <td class="paramname"><em>returnInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a single instance. </p>
<p>This function creates a single instance of the BEAGLE library and can be called multiple times to create multiple data partition instances each returning a unique identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tipCount</td><td>Number of tip data elements (input) </td></tr>
    <tr><td class="paramname">partialsBufferCount</td><td>Number of partials buffers to create (input) </td></tr>
    <tr><td class="paramname">compactBufferCount</td><td>Number of compact state representation buffers to create (input) </td></tr>
    <tr><td class="paramname">stateCount</td><td>Number of states in the continuous-time Markov chain (input) </td></tr>
    <tr><td class="paramname">patternCount</td><td>Number of site patterns to be handled by the instance (input) </td></tr>
    <tr><td class="paramname">eigenBufferCount</td><td>Number of rate matrix eigen-decomposition, category weight, and state frequency buffers to allocate (input) </td></tr>
    <tr><td class="paramname">matrixBufferCount</td><td>Number of transition probability matrix buffers (input) </td></tr>
    <tr><td class="paramname">categoryCount</td><td>Number of rate categories (input) </td></tr>
    <tr><td class="paramname">scaleBufferCount</td><td>Number of scale buffers to create, ignored for auto scale or always scale (input) </td></tr>
    <tr><td class="paramname">resourceList</td><td>List of potential resources on which this instance is allowed (input, NULL implies no restriction) </td></tr>
    <tr><td class="paramname">resourceCount</td><td>Length of resourceList list (input) </td></tr>
    <tr><td class="paramname">preferenceFlags</td><td>Bit-flags indicating preferred implementation characteristics, see BeagleFlags (input) </td></tr>
    <tr><td class="paramname">requirementFlags</td><td>Bit-flags indicating required implementation characteristics, see BeagleFlags (input) </td></tr>
    <tr><td class="paramname">returnInfo</td><td>Pointer to return implementation and resource details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique instance identifier (&lt;0 if failed, see <a class="el" href="beagle_8h.html#BEAGLE_RETURN_CODES">BeagleReturnCodes</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a7c5d6a18112618e6e4955d7f7dc22617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleFinalize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize the library. </p>
<p>This function finalizes the library and releases all allocated memory. This function is automatically called under GNU C via <b>attribute</b> ((destructor)).</p>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aa35df026165d96afb3a09079126666dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleFinalizeInstance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize this instance. </p>
<p>This function finalizes the instance by releasing allocated memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aa057301859e993ba24d5b9fdc7f7ecd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT const char* beagleGetCitation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get citation. </p>
<p>This function returns a pointer to a string describing the version of the library and how to cite it.</p>
<dl class="section return"><dt>Returns</dt><dd>A string describing the version of the library and how to cite it </dd></dl>

</div>
</div>
<a class="anchor" id="a6f698c0acaf059732079e854682ab8bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleGetPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partials from an instance buffer. </p>
<p>This function copies an instance buffer into the array outPartials. The outPartials array should be stateCount * patternCount * categoryCount in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number from which to get partialsBuffer (input) </td></tr>
    <tr><td class="paramname">bufferIndex</td><td>Index of source partialsBuffer (input) </td></tr>
    <tr><td class="paramname">scaleIndex</td><td>Index of scaleBuffer to apply to partialsBuffer (input) </td></tr>
    <tr><td class="paramname">outPartials</td><td>Pointer to which to receive partialsBuffer (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a389ba7c4a2e4ec083fada4b43d15df16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT <a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a>* beagleGetResourceList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of hardware resources. </p>
<p>This function returns a pointer to a <a class="el" href="struct_beagle_resource_list.html" title="List of hardware resources. ">BeagleResourceList</a> struct, which includes a <a class="el" href="struct_beagle_resource.html" title="Description of a hardware resource. ">BeagleResource</a> array describing the available hardware resources.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of hardware resources available to the library as a <a class="el" href="struct_beagle_resource_list.html" title="List of hardware resources. ">BeagleResourceList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd7856124724dc18058935d8aaa08ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleGetSiteDerivatives </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outFirstDerivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSecondDerivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get site derivatives for last beagleCalculateEdgeLogLikelihoods call. </p>
<p>This function returns the derivatives for each site</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">outFirstDerivatives</td><td>Pointer to destination for resulting first derivatives (output) </td></tr>
    <tr><td class="paramname">outSecondDerivatives</td><td>Pointer to destination for resulting second derivatives (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a8de7a453b2d4a89be02f75f8e9ae9ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleGetSiteLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outLogLikelihoods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call. </p>
<p>This function returns the log likelihoods for each site</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">outLogLikelihoods</td><td>Pointer to destination for resulting log likelihoods (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a4054c89db17dd5cc50c0f1c077bee8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleGetTransitionMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a finite-time transition probability matrix. </p>
<p>This function copies a finite-time transition matrix buffer into the array outMatrix. The outMatrix array should be of size stateCount * stateCount * categoryCount and will be filled with one matrix for each rate category.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndex</td><td>Index of matrix buffer (input) </td></tr>
    <tr><td class="paramname">outMatrix</td><td>Pointer to destination transition probability matrix (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a7548767f2cb3af22eeaec53033b826e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT const char* beagleGetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version. </p>
<p>This function returns a pointer to a string with the library version number.</p>
<dl class="section return"><dt>Returns</dt><dd>A string with the version number </dd></dl>

</div>
</div>
<a class="anchor" id="a0703dedf208d98a4b86ea8ee0b2e358d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleRemoveScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>scaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove scale factors. </p>
<p>This function removes (log) scale factors from a cumulative scale buffer. The scale factors to be removed are indicated in a list of scaleBuffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">scaleIndices</td><td>List of scaleBuffers to remove (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of scaleBuffers in list (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer containing accumulated factors (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0b1d6509865e06715cf96b7f5ec0b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleResetScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset scalefactors. </p>
<p>This function resets a cumulative scale buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of cumulative scaleBuffer (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a404a18af42b3eb11d1d7dc8c86204ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetCategoryRates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inCategoryRates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set category rates. </p>
<p>This function sets the vector of category rates for an instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">inCategoryRates</td><td>Array containing categoryCount rate scalers (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a9e162e36113dfd5edb1dc57c2e99e3b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetCategoryWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>categoryWeightsIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inCategoryWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a category weights buffer. </p>
<p>This function copies a category weights array into an instance buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndex</td><td>Index of category weights buffer (input) </td></tr>
    <tr><td class="paramname">inCategoryWeights</td><td>Category weights array (categoryCount) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aae27b7b658d2a30a520190915ac10ae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetEigenDecomposition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inEigenVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inInverseEigenVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inEigenValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an eigen-decomposition buffer. </p>
<p>This function copies an eigen-decomposition into an instance buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">eigenIndex</td><td>Index of eigen-decomposition buffer (input) </td></tr>
    <tr><td class="paramname">inEigenVectors</td><td>Flattened matrix (stateCount x stateCount) of eigen-vectors (input) </td></tr>
    <tr><td class="paramname">inInverseEigenVectors</td><td>Flattened matrix (stateCount x stateCount) of inverse-eigen- vectors (input) </td></tr>
    <tr><td class="paramname">inEigenValues</td><td>Vector of eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a4d9587451dddf791c2b28de95b91a8aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an instance partials buffer. </p>
<p>This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount * categoryCount in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number in which to set a partialsBuffer (input) </td></tr>
    <tr><td class="paramname">bufferIndex</td><td>Index of destination partialsBuffer (input) </td></tr>
    <tr><td class="paramname">inPartials</td><td>Pointer to partials values to set (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aebbfc9e38a2dd362b0f03f29cab42ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetPatternWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPatternWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set pattern weights. </p>
<p>This function sets the vector of pattern weights for an instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">inPatternWeights</td><td>Array containing patternCount weights (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aed8f0f07b5510150efe1b72df2270f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetStateFrequencies </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inStateFrequencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a state frequency buffer. </p>
<p>This function copies a state frequency array into an instance buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">stateFrequenciesIndex</td><td>Index of state frequencies buffer (input) </td></tr>
    <tr><td class="paramname">inStateFrequencies</td><td>State frequencies array (stateCount) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a8da6fcc385325ac71c0268ba49c91735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetTipPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an instance partials buffer for tip node. </p>
<p>This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount in length. For most applications this will be used to set the partial likelihoods for the observed states. Internally, the partials will be copied categoryCount times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number in which to set a partialsBuffer (input) </td></tr>
    <tr><td class="paramname">tipIndex</td><td>Index of destination partialsBuffer (input) </td></tr>
    <tr><td class="paramname">inPartials</td><td>Pointer to partials values to set (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a248ac2d4e93da19d4598a488545beb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetTipStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>inStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the compact state representation for tip node. </p>
<p>This function copies a compact state representation into an instance buffer. Compact state representation is an array of states: 0 to stateCount - 1 (missing = stateCount). The inStates array should be patternCount in length (replication across categoryCount is not required).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">tipIndex</td><td>Index of destination compactBuffer (input) </td></tr>
    <tr><td class="paramname">inStates</td><td>Pointer to compact states (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a72c7aac15b0cc06f03e6177ad0a161e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetTransitionMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>matrixIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inMatrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>paddedValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multiple transition matrices. </p>
<p>This function copies multiple transition matrices into matrix buffers. This function is used when the application wishes to explicitly set the transition matrices rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrices array should be of size stateCount * stateCount * categoryCount * count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndices</td><td>Indices of matrix buffers (input) </td></tr>
    <tr><td class="paramname">inMatrices</td><td>Pointer to source transition matrices (input) </td></tr>
    <tr><td class="paramname">paddedValues</td><td>Values to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of transition matrices (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ac209b67480022546bed413034bf771a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleSetTransitionMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>paddedValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a finite-time transition probability matrix. </p>
<p>This function copies a finite-time transition probability matrix into a matrix buffer. This function is used when the application wishes to explicitly set the transition probability matrix rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrix array should be of size stateCount * stateCount * categoryCount and will contain one matrix for each rate category.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndex</td><td>Index of matrix buffer (input) </td></tr>
    <tr><td class="paramname">inMatrix</td><td>Pointer to source transition probability matrix (input) </td></tr>
    <tr><td class="paramname">paddedValue</td><td>Value to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a1c6335b5efc17f331282daec82e94226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleUpdatePartials </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_beagle_operation.html">BeagleOperation</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate or queue for calculation partials using a list of operations. </p>
<p>This function either calculates or queues for calculation a list partials. Implementations supporting ASYNCH may queue these calculations while other implementations perform these operations immediately and in order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">operations</td><td><a class="el" href="struct_beagle_operation.html" title="A list of integer indices which specify a partial likelihoods operation. ">BeagleOperation</a> list specifying operations (input) </td></tr>
    <tr><td class="paramname">operationCount</td><td>Number of operations (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer to store accumulated factors (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a5528ac9d57faaa14947260a297496269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleUpdateTransitionMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>probabilityIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>edgeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a list of transition probability matrices. </p>
<p>This function calculates a list of transition probabilities matrices and their first and second derivatives (if requested).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">eigenIndex</td><td>Index of eigen-decomposition buffer (input) </td></tr>
    <tr><td class="paramname">probabilityIndices</td><td>List of indices of transition probability matrices to update (input) </td></tr>
    <tr><td class="paramname">firstDerivativeIndices</td><td>List of indices of first derivative matrices to update (input, NULL implies no calculation) </td></tr>
    <tr><td class="paramname">secondDerivativeIndices</td><td>List of indices of second derivative matrices to update (input, NULL implies no calculation) </td></tr>
    <tr><td class="paramname">edgeLengths</td><td>List of edge lengths with which to perform calculations (input) </td></tr>
    <tr><td class="paramname">count</td><td>Length of lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ab34345b9feb1a92a9ed247dbb93192b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEAGLE_DLLEXPORT int beagleWaitForPartials </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinationPartials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationPartialsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until all calculations that write to the specified partials have completed. </p>
<p>This function is optional and only has to be called by clients that "recycle" partials.</p>
<p>If used, this function must be called after an beagleUpdatePartials call and must refer to indices of "destinationPartials" that were used in a previous beagleUpdatePartials call. The library will block until those partials have been calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">destinationPartials</td><td>List of the indices of destinationPartials that must be calculated before the function returns </td></tr>
    <tr><td class="paramname">destinationPartialsCount</td><td>Number of destinationPartials (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 15 2013 22:37:39 for BEAGLE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
