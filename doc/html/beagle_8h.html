<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BEAGLE: libhmsbeagle/beagle.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="beagle-dox.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BEAGLE
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">An Application Programming Interface and High-Performance Computing Library for Statistical Phylogenetics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libhmsbeagle/beagle.h File Reference</div>  </div>
</div>
<div class="contents">

<p>This file documents the API as well as header for the Broad-platform Evolutionary Analysis General Likelihood Evaluator.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;libhmsbeagle/platform.h&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for beagle.h:</div>
<div class="dyncontent">
<div class="center"><img src="beagle_8h__incl.png" border="0" usemap="#libhmsbeagle_2beagle_8h" alt=""/></div>
<map name="libhmsbeagle_2beagle_8h" id="libhmsbeagle_2beagle_8h">
</map>
</div>
</div>
<p><a href="beagle_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a specific instance.  <a href="struct_beagle_instance_details.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_resource.html">BeagleResource</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a hardware resource.  <a href="struct_beagle_resource.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List of hardware resources.  <a href="struct_beagle_resource_list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_beagle_operation.html">BeagleOperation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of integer indices which specify a partial likelihoods operation.  <a href="struct_beagle_operation.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">BeagleReturnCodes</a> { <br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea12aea4769c1be89867846782925b1cbe">BEAGLE_SUCCESS</a> =  0, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea45c3bd53fdd83865d927202d0d582299">BEAGLE_ERROR_GENERAL</a> =  -1, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaf31bb198b162f0d9ed2e0490a475409d">BEAGLE_ERROR_OUT_OF_MEMORY</a> =  -2, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea3fd3b3dc476c527884e6db3dc0d13738">BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION</a> =  -3, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaba333086a5777117202ed0f16109157a">BEAGLE_ERROR_UNINITIALIZED_INSTANCE</a> =  -4, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea1118b576b6d5e1372f757ec246acd203">BEAGLE_ERROR_OUT_OF_RANGE</a> =  -5, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfceaec9b03ad5cd754a99ed84e1755704beb">BEAGLE_ERROR_NO_RESOURCE</a> =  -6, 
<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea74be6f002aba021c7093dfe50b44f1ed">BEAGLE_ERROR_NO_IMPLEMENTATION</a> =  -7, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfcea267dcbe8ced105decc94598ba2be51ba">BEAGLE_ERROR_FLOATING_POINT</a> =  -8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error return codes.  <a href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">BeagleFlags</a> { <br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea6efa1e464b74cfcf6e7317d79bf1c085">BEAGLE_FLAG_PRECISION_SINGLE</a> =  1 &lt;&lt; 0, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea83963bbb1062fd6c060553de8dd6b429">BEAGLE_FLAG_PRECISION_DOUBLE</a> =  1 &lt;&lt; 1, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac4e28e01f5d95262033f72410ca57c89">BEAGLE_FLAG_COMPUTATION_SYNCH</a> =  1 &lt;&lt; 2, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac2cf9217aa4e7a2e002746528a8ba29b">BEAGLE_FLAG_COMPUTATION_ASYNCH</a> =  1 &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea96ef202a6ec8fc3754dc3095b30a87fb">BEAGLE_FLAG_EIGEN_REAL</a> =  1 &lt;&lt; 4, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea5a64736d6ca8cd54532e35f597671f16">BEAGLE_FLAG_EIGEN_COMPLEX</a> =  1 &lt;&lt; 5, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea44746eb12a08bd5427ecf7e0508e02e9">BEAGLE_FLAG_SCALING_MANUAL</a> =  1 &lt;&lt; 6, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea78667e7bb79ac6c002d0180d3e27d6b5">BEAGLE_FLAG_SCALING_AUTO</a> =  1 &lt;&lt; 7, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea11d8bbb56c0d104bf29e877f90f12935">BEAGLE_FLAG_SCALING_ALWAYS</a> =  1 &lt;&lt; 8, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea8c750c64eb7c532c40a1b520c7253656">BEAGLE_FLAG_SCALING_DYNAMIC</a> =  1 &lt;&lt; 19, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea81574eae3cca4fd42b3b34d731555b64">BEAGLE_FLAG_SCALERS_RAW</a> =  1 &lt;&lt; 9, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea90091808850e51109fcb2f06fc8eb6f3">BEAGLE_FLAG_SCALERS_LOG</a> =  1 &lt;&lt; 10, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeadbd1b3e83d25b5fae3a14a724b24cec2">BEAGLE_FLAG_INVEVEC_STANDARD</a> =  1 &lt;&lt; 20, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9fc181aac842ebac6d51ccb19cf0e2ca">BEAGLE_FLAG_INVEVEC_TRANSPOSED</a> =  1 &lt;&lt; 21, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea6f9a787ae342115c27a7437e8b0d9dc6">BEAGLE_FLAG_VECTOR_SSE</a> =  1 &lt;&lt; 11, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea538654597350cea65553c70189ceb107">BEAGLE_FLAG_VECTOR_NONE</a> =  1 &lt;&lt; 12, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeac522542d33f45928656aa2dfe478b3ce">BEAGLE_FLAG_THREADING_OPENMP</a> =  1 &lt;&lt; 13, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea444ce15e77f6cfaeb77ee1762925cd77">BEAGLE_FLAG_THREADING_NONE</a> =  1 &lt;&lt; 14, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9aea9b1db1765a059e5f0c994c7ff5b4">BEAGLE_FLAG_PROCESSOR_CPU</a> =  1 &lt;&lt; 15, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddeaf7a580b8584fbdba42c5a1bab2b6ed6c">BEAGLE_FLAG_PROCESSOR_GPU</a> =  1 &lt;&lt; 16, 
<br/>
&#160;&#160;<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea9480c27a220b39df8980176376e27bbf">BEAGLE_FLAG_PROCESSOR_FPGA</a> =  1 &lt;&lt; 17, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea5dcb70fa15d216e8295982953d535ff9">BEAGLE_FLAG_PROCESSOR_CELL</a> =  1 &lt;&lt; 18, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea40c7b4711118fb6fa14e697a698eda87">BEAGLE_FLAG_FRAMEWORK_CUDA</a> =  1 &lt;&lt; 22, 
<a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bddea04dcbc29ff83699be424c21b38e57d06">BEAGLE_FLAG_FRAMEWORK_OPENCL</a> =  1 &lt;&lt; 23
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware and implementation capability flags.  <a href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">BeagleOpCodes</a> { <a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55ca907d2c6aac07be265a496476a55216e5">BEAGLE_OP_COUNT</a> =  7, 
<a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55ca2eb262bbe41b1dbeff3e189d8de65b04">BEAGLE_OP_NONE</a> =  -1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation codes.  <a href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a5608865bb1bac391da13758bcc04797f">beagleGetResourceList</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of hardware resources.  <a href="#a5608865bb1bac391da13758bcc04797f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ae86077bd2c778a0adddcb2c6aafd538e">beagleCreateInstance</a> (int tipCount, int partialsBufferCount, int compactBufferCount, int stateCount, int patternCount, int eigenBufferCount, int matrixBufferCount, int categoryCount, int scaleBufferCount, int *resourceList, int resourceCount, long preferenceFlags, long requirementFlags, <a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a> *returnInfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a single instance.  <a href="#ae86077bd2c778a0adddcb2c6aafd538e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a1a323eecf18b20ced4e787de47ab1693">beagleFinalizeInstance</a> (int instance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize this instance.  <a href="#a1a323eecf18b20ced4e787de47ab1693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a7ef4ef3a5c331f66823d72eb9675d487">beagleFinalize</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the library.  <a href="#a7ef4ef3a5c331f66823d72eb9675d487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a740b58891b46401309f9b524842c5073">beagleSetTipStates</a> (int instance, int tipIndex, const int *inStates)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the compact state representation for tip node.  <a href="#a740b58891b46401309f9b524842c5073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ad11209a76797cec7ee83d2be0cf3f6f7">beagleSetTipPartials</a> (int instance, int tipIndex, const double *inPartials)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an instance partials buffer for tip node.  <a href="#ad11209a76797cec7ee83d2be0cf3f6f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ad4ee216eb5186b31db462aa199a06c6a">beagleSetPartials</a> (int instance, int bufferIndex, const double *inPartials)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an instance partials buffer.  <a href="#ad4ee216eb5186b31db462aa199a06c6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a3c5b920cd185992708f3c5b7b2a0f8c7">beagleGetPartials</a> (int instance, int bufferIndex, int scaleIndex, double *outPartials)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partials from an instance buffer.  <a href="#a3c5b920cd185992708f3c5b7b2a0f8c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a64c9222387b3e46bf0169f4cf7c5a713">beagleSetEigenDecomposition</a> (int instance, int eigenIndex, const double *inEigenVectors, const double *inInverseEigenVectors, const double *inEigenValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an eigen-decomposition buffer.  <a href="#a64c9222387b3e46bf0169f4cf7c5a713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aabbd1b0c83b7abddc4cdbc266cab3ddd">beagleSetStateFrequencies</a> (int instance, int stateFrequenciesIndex, const double *inStateFrequencies)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a state frequency buffer.  <a href="#aabbd1b0c83b7abddc4cdbc266cab3ddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ac2a3f778a939fec8007c52957672b10e">beagleSetCategoryWeights</a> (int instance, int categoryWeightsIndex, const double *inCategoryWeights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a category weights buffer.  <a href="#ac2a3f778a939fec8007c52957672b10e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a507aa622001b43673de92e52b68d59db">beagleSetCategoryRates</a> (int instance, const double *inCategoryRates)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set category rates.  <a href="#a507aa622001b43673de92e52b68d59db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a254ee344c0b6e912b4105dddbb377bd8">beagleSetPatternWeights</a> (int instance, const double *inPatternWeights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pattern weights.  <a href="#a254ee344c0b6e912b4105dddbb377bd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#afd6da9bba8e5a0cc10bc83a5ff08f61c">beagleUpdateTransitionMatrices</a> (int instance, int eigenIndex, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const double *edgeLengths, int count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a list of transition probability matrices.  <a href="#afd6da9bba8e5a0cc10bc83a5ff08f61c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ab6c2e40b1be12673a284bc00174e523f">beagleSetTransitionMatrix</a> (int instance, int matrixIndex, const double *inMatrix, double paddedValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a finite-time transition probability matrix.  <a href="#ab6c2e40b1be12673a284bc00174e523f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ac36e6cccc8e36263a2bf4c3d4cfbe93d">beagleGetTransitionMatrix</a> (int instance, int matrixIndex, double *outMatrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a finite-time transition probability matrix.  <a href="#ac36e6cccc8e36263a2bf4c3d4cfbe93d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ac13c2302faf8fca8dc5bbbde52a25c3a">beagleSetTransitionMatrices</a> (int instance, const int *matrixIndices, const double *inMatrices, const double *paddedValues, int count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple transition matrices.  <a href="#ac13c2302faf8fca8dc5bbbde52a25c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#a60a7d64445811dd8075d3f728fbd1ca6">beagleUpdatePartials</a> (const int instance, const <a class="el" href="struct_beagle_operation.html">BeagleOperation</a> *operations, int operationCount, int cumulativeScaleIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate or queue for calculation partials using a list of operations.  <a href="#a60a7d64445811dd8075d3f728fbd1ca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aec7540bfa4f340a16294c4a1306129b9">beagleWaitForPartials</a> (const int instance, const int *destinationPartials, int destinationPartialsCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all calculations that write to the specified partials have completed.  <a href="#aec7540bfa4f340a16294c4a1306129b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aeb435552108e272c036d89d9b725910b">beagleAccumulateScaleFactors</a> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate scale factors.  <a href="#aeb435552108e272c036d89d9b725910b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aac6b1cdf0de893bc0bad8f70c29f5b11">beagleRemoveScaleFactors</a> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove scale factors.  <a href="#aac6b1cdf0de893bc0bad8f70c29f5b11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#aec2b3b765ab40d575b3f6aeab68683d7">beagleResetScaleFactors</a> (int instance, int cumulativeScaleIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset scalefactors.  <a href="#aec2b3b765ab40d575b3f6aeab68683d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#adc42e82d3c53cd203c1a51e7b35add90">beagleCopyScaleFactors</a> (int instance, int destScalingIndex, int srcScalingIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy scale factors.  <a href="#adc42e82d3c53cd203c1a51e7b35add90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#adfb8c177b803aeef15daa9ed4c019e31">beagleCalculateRootLogLikelihoods</a> (int instance, const int *bufferIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate site log likelihoods at a root node.  <a href="#adfb8c177b803aeef15daa9ed4c019e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ac2ea99215d252187479972517b4557d2">beagleCalculateEdgeLogLikelihoods</a> (int instance, const int *parentBufferIndices, const int *childBufferIndices, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood, double *outSumFirstDerivative, double *outSumSecondDerivative)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate site log likelihoods and derivatives along an edge.  <a href="#ac2ea99215d252187479972517b4557d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#ad54f99e2ed159883406b3f3c334122f5">beagleGetSiteLogLikelihoods</a> (int instance, double *outLogLikelihoods)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call.  <a href="#ad54f99e2ed159883406b3f3c334122f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beagle_8h.html#acc5f5ef36423458ccde69f1c282fe653">beagleGetSiteDerivatives</a> (int instance, double *outFirstDerivatives, double *outSecondDerivatives)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get site derivatives for last beagleCalculateEdgeLogLikelihoods call.  <a href="#acc5f5ef36423458ccde69f1c282fe653"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file documents the API as well as header for the Broad-platform Evolutionary Analysis General Likelihood Evaluator. </p>
<p>Copyright 2009-2011 Phylogenetic Likelihood Working Group</p>
<p>This file is part of BEAGLE.</p>
<p>BEAGLE is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>BEAGLE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with BEAGLE. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
<p>KEY CONCEPTS</p>
<p>The key to BEAGLE performance lies in delivering fine-scale parallelization while minimizing data transfer and memory copy overhead. To accomplish this, the library lacks the concept or data structure for a tree, in spite of the intended use for phylogenetic analysis. Instead, BEAGLE acts directly on flexibly indexed data storage (called buffers) for observed character states and partial likelihoods. The client program can set the input buffers to reflect the data and can calculate the likelihood of a particular phylogeny by invoking likelihood calculations on the appropriate input and output buffers in the correct order. Because of this design simplicity, the library can support many different tree inference algorithms and likelihood calculation on a variety of models. Arbitrary numbers of states can be used, as can nonreversible substitution matrices via complex eigen decompositions, and mixture models with multiple rate categories and/or multiple eigen decompositions. Finally, BEAGLE application programming interface (API) calls can be asynchronous, allowing the calling program to implement other coarse-scale parallelization schemes such as evaluating independent genes or running concurrent Markov chains.</p>
<p>USAGE</p>
<p>To use the library, a client program first creates an instance of BEAGLE by calling beagleCreateInstance; multiple instances per client are possible and encouraged. All additional functions are called with a reference to this instance. The client program can optionally request that an instance run on certain hardware (e.g., a GPU) or have particular features (e.g., double-precision math). Next, the client program must specify the data dimensions and specify key aspects of the phylogenetic model. Character state data are then loaded and can be in the form of discrete observed states or partial likelihoods for ambiguous characters. The observed data are usually unchanging and loaded only once at the start to minimize memory copy overhead. The character data can be compressed into unique “site patterns” and associated weights for each. The parameters of the substitution process can then be specified, including the equilibrium state frequencies, the rates for one or more substitution rate categories and their weights, and finally, the eigen decomposition for the substitution process.</p>
<p>In order to calculate the likelihood of a particular tree, the client program then specifies a series of integration operations that correspond to steps in Felsenstein’s algorithm. Finite-time transition probabilities for each edge are loaded directly if considering a nondiagonalizable model or calculated in parallel from the eigen decomposition and edge lengths specified. This is performed within BEAGLE’s memory space to minimize data transfers. A single function call will then request one or more integration operations to calculate partial likelihoods over some or all nodes. The operations are performed in the order they are provided, typically dictated by a postorder traversal of the tree topology. The client needs only specify nodes for which the partial likelihoods need updating, but it is up to the calling software to keep track of these dependencies. The final step in evaluating the phylogenetic model is done using an API call that yields a single log likelihood for the model given the data.</p>
<p>Aspects of the BEAGLE API design support both maximum likelihood (ML) and Bayesian phylogenetic tree inference. For ML inference, API calls can calculate first and second derivatives of the likelihood with respect to the lengths of edges (branches). In both cases, BEAGLE provides the ability to cache and reuse previously computed partial likelihood results, which can yield a tremendous speedup over recomputing the entire likelihood every time a new phylogenetic model is evaluated.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Likelihood API Working Group</dd>
<dd>
Daniel Ayres </dd>
<dd>
Peter Beerli </dd>
<dd>
Michael Cummings </dd>
<dd>
Aaron Darling </dd>
<dd>
Mark Holder </dd>
<dd>
John Huelsenbeck </dd>
<dd>
Paul Lewis </dd>
<dd>
Michael Ott </dd>
<dd>
Andrew Rambaut </dd>
<dd>
Fredrik Ronquist </dd>
<dd>
Marc Suchard </dd>
<dd>
David Swofford </dd>
<dd>
Derrick Zwickl </dd></dl>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bdde"></a><!-- doxytag: member="beagle.h::BeagleFlags" ref="a3f3abf6b7c463b689a26ec83fb14bdde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a3f3abf6b7c463b689a26ec83fb14bdde">BeagleFlags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hardware and implementation capability flags. </p>
<p><a class="anchor" id="BEAGLE_FLAGS"></a> This enumerates all possible hardware and implementation capability flags. Each capability is a bit in a 'long' </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea6efa1e464b74cfcf6e7317d79bf1c085"></a><!-- doxytag: member="BEAGLE_FLAG_PRECISION_SINGLE" ref="a3f3abf6b7c463b689a26ec83fb14bddea6efa1e464b74cfcf6e7317d79bf1c085" args="" -->BEAGLE_FLAG_PRECISION_SINGLE</em>&nbsp;</td><td>
<p>Single precision computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea83963bbb1062fd6c060553de8dd6b429"></a><!-- doxytag: member="BEAGLE_FLAG_PRECISION_DOUBLE" ref="a3f3abf6b7c463b689a26ec83fb14bddea83963bbb1062fd6c060553de8dd6b429" args="" -->BEAGLE_FLAG_PRECISION_DOUBLE</em>&nbsp;</td><td>
<p>Double precision computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac4e28e01f5d95262033f72410ca57c89"></a><!-- doxytag: member="BEAGLE_FLAG_COMPUTATION_SYNCH" ref="a3f3abf6b7c463b689a26ec83fb14bddeac4e28e01f5d95262033f72410ca57c89" args="" -->BEAGLE_FLAG_COMPUTATION_SYNCH</em>&nbsp;</td><td>
<p>Synchronous computation (blocking) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac2cf9217aa4e7a2e002746528a8ba29b"></a><!-- doxytag: member="BEAGLE_FLAG_COMPUTATION_ASYNCH" ref="a3f3abf6b7c463b689a26ec83fb14bddeac2cf9217aa4e7a2e002746528a8ba29b" args="" -->BEAGLE_FLAG_COMPUTATION_ASYNCH</em>&nbsp;</td><td>
<p>Asynchronous computation (non-blocking) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea96ef202a6ec8fc3754dc3095b30a87fb"></a><!-- doxytag: member="BEAGLE_FLAG_EIGEN_REAL" ref="a3f3abf6b7c463b689a26ec83fb14bddea96ef202a6ec8fc3754dc3095b30a87fb" args="" -->BEAGLE_FLAG_EIGEN_REAL</em>&nbsp;</td><td>
<p>Real eigenvalue computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea5a64736d6ca8cd54532e35f597671f16"></a><!-- doxytag: member="BEAGLE_FLAG_EIGEN_COMPLEX" ref="a3f3abf6b7c463b689a26ec83fb14bddea5a64736d6ca8cd54532e35f597671f16" args="" -->BEAGLE_FLAG_EIGEN_COMPLEX</em>&nbsp;</td><td>
<p>Complex eigenvalue computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea44746eb12a08bd5427ecf7e0508e02e9"></a><!-- doxytag: member="BEAGLE_FLAG_SCALING_MANUAL" ref="a3f3abf6b7c463b689a26ec83fb14bddea44746eb12a08bd5427ecf7e0508e02e9" args="" -->BEAGLE_FLAG_SCALING_MANUAL</em>&nbsp;</td><td>
<p>Manual scaling </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea78667e7bb79ac6c002d0180d3e27d6b5"></a><!-- doxytag: member="BEAGLE_FLAG_SCALING_AUTO" ref="a3f3abf6b7c463b689a26ec83fb14bddea78667e7bb79ac6c002d0180d3e27d6b5" args="" -->BEAGLE_FLAG_SCALING_AUTO</em>&nbsp;</td><td>
<p>Auto-scaling on </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea11d8bbb56c0d104bf29e877f90f12935"></a><!-- doxytag: member="BEAGLE_FLAG_SCALING_ALWAYS" ref="a3f3abf6b7c463b689a26ec83fb14bddea11d8bbb56c0d104bf29e877f90f12935" args="" -->BEAGLE_FLAG_SCALING_ALWAYS</em>&nbsp;</td><td>
<p>Scale at every updatePartials </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea8c750c64eb7c532c40a1b520c7253656"></a><!-- doxytag: member="BEAGLE_FLAG_SCALING_DYNAMIC" ref="a3f3abf6b7c463b689a26ec83fb14bddea8c750c64eb7c532c40a1b520c7253656" args="" -->BEAGLE_FLAG_SCALING_DYNAMIC</em>&nbsp;</td><td>
<p>Manual scaling with dynamic checking </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea81574eae3cca4fd42b3b34d731555b64"></a><!-- doxytag: member="BEAGLE_FLAG_SCALERS_RAW" ref="a3f3abf6b7c463b689a26ec83fb14bddea81574eae3cca4fd42b3b34d731555b64" args="" -->BEAGLE_FLAG_SCALERS_RAW</em>&nbsp;</td><td>
<p>Save raw scalers </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea90091808850e51109fcb2f06fc8eb6f3"></a><!-- doxytag: member="BEAGLE_FLAG_SCALERS_LOG" ref="a3f3abf6b7c463b689a26ec83fb14bddea90091808850e51109fcb2f06fc8eb6f3" args="" -->BEAGLE_FLAG_SCALERS_LOG</em>&nbsp;</td><td>
<p>Save log scalers </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeadbd1b3e83d25b5fae3a14a724b24cec2"></a><!-- doxytag: member="BEAGLE_FLAG_INVEVEC_STANDARD" ref="a3f3abf6b7c463b689a26ec83fb14bddeadbd1b3e83d25b5fae3a14a724b24cec2" args="" -->BEAGLE_FLAG_INVEVEC_STANDARD</em>&nbsp;</td><td>
<p>Inverse eigen vectors passed to BEAGLE have not been transposed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9fc181aac842ebac6d51ccb19cf0e2ca"></a><!-- doxytag: member="BEAGLE_FLAG_INVEVEC_TRANSPOSED" ref="a3f3abf6b7c463b689a26ec83fb14bddea9fc181aac842ebac6d51ccb19cf0e2ca" args="" -->BEAGLE_FLAG_INVEVEC_TRANSPOSED</em>&nbsp;</td><td>
<p>Inverse eigen vectors passed to BEAGLE have been transposed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea6f9a787ae342115c27a7437e8b0d9dc6"></a><!-- doxytag: member="BEAGLE_FLAG_VECTOR_SSE" ref="a3f3abf6b7c463b689a26ec83fb14bddea6f9a787ae342115c27a7437e8b0d9dc6" args="" -->BEAGLE_FLAG_VECTOR_SSE</em>&nbsp;</td><td>
<p>SSE computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea538654597350cea65553c70189ceb107"></a><!-- doxytag: member="BEAGLE_FLAG_VECTOR_NONE" ref="a3f3abf6b7c463b689a26ec83fb14bddea538654597350cea65553c70189ceb107" args="" -->BEAGLE_FLAG_VECTOR_NONE</em>&nbsp;</td><td>
<p>No vector computation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeac522542d33f45928656aa2dfe478b3ce"></a><!-- doxytag: member="BEAGLE_FLAG_THREADING_OPENMP" ref="a3f3abf6b7c463b689a26ec83fb14bddeac522542d33f45928656aa2dfe478b3ce" args="" -->BEAGLE_FLAG_THREADING_OPENMP</em>&nbsp;</td><td>
<p>OpenMP threading </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea444ce15e77f6cfaeb77ee1762925cd77"></a><!-- doxytag: member="BEAGLE_FLAG_THREADING_NONE" ref="a3f3abf6b7c463b689a26ec83fb14bddea444ce15e77f6cfaeb77ee1762925cd77" args="" -->BEAGLE_FLAG_THREADING_NONE</em>&nbsp;</td><td>
<p>No threading </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9aea9b1db1765a059e5f0c994c7ff5b4"></a><!-- doxytag: member="BEAGLE_FLAG_PROCESSOR_CPU" ref="a3f3abf6b7c463b689a26ec83fb14bddea9aea9b1db1765a059e5f0c994c7ff5b4" args="" -->BEAGLE_FLAG_PROCESSOR_CPU</em>&nbsp;</td><td>
<p>Use CPU as main processor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddeaf7a580b8584fbdba42c5a1bab2b6ed6c"></a><!-- doxytag: member="BEAGLE_FLAG_PROCESSOR_GPU" ref="a3f3abf6b7c463b689a26ec83fb14bddeaf7a580b8584fbdba42c5a1bab2b6ed6c" args="" -->BEAGLE_FLAG_PROCESSOR_GPU</em>&nbsp;</td><td>
<p>Use GPU as main processor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea9480c27a220b39df8980176376e27bbf"></a><!-- doxytag: member="BEAGLE_FLAG_PROCESSOR_FPGA" ref="a3f3abf6b7c463b689a26ec83fb14bddea9480c27a220b39df8980176376e27bbf" args="" -->BEAGLE_FLAG_PROCESSOR_FPGA</em>&nbsp;</td><td>
<p>Use FPGA as main processor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea5dcb70fa15d216e8295982953d535ff9"></a><!-- doxytag: member="BEAGLE_FLAG_PROCESSOR_CELL" ref="a3f3abf6b7c463b689a26ec83fb14bddea5dcb70fa15d216e8295982953d535ff9" args="" -->BEAGLE_FLAG_PROCESSOR_CELL</em>&nbsp;</td><td>
<p>Use Cell as main processor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea40c7b4711118fb6fa14e697a698eda87"></a><!-- doxytag: member="BEAGLE_FLAG_FRAMEWORK_CUDA" ref="a3f3abf6b7c463b689a26ec83fb14bddea40c7b4711118fb6fa14e697a698eda87" args="" -->BEAGLE_FLAG_FRAMEWORK_CUDA</em>&nbsp;</td><td>
<p>Use CUDA implementation with GPU resources </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f3abf6b7c463b689a26ec83fb14bddea04dcbc29ff83699be424c21b38e57d06"></a><!-- doxytag: member="BEAGLE_FLAG_FRAMEWORK_OPENCL" ref="a3f3abf6b7c463b689a26ec83fb14bddea04dcbc29ff83699be424c21b38e57d06" args="" -->BEAGLE_FLAG_FRAMEWORK_OPENCL</em>&nbsp;</td><td>
<p>Use OpenCL implementation with GPU resources </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55c"></a><!-- doxytag: member="beagle.h::BeagleOpCodes" ref="a2487a1c99f4214cd3a70468d0ccac55c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a2487a1c99f4214cd3a70468d0ccac55c">BeagleOpCodes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operation codes. </p>
<p><a class="anchor" id="BEAGLE_OP_CODES"></a> This enumerates all possible BEAGLE operation codes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55ca907d2c6aac07be265a496476a55216e5"></a><!-- doxytag: member="BEAGLE_OP_COUNT" ref="a2487a1c99f4214cd3a70468d0ccac55ca907d2c6aac07be265a496476a55216e5" args="" -->BEAGLE_OP_COUNT</em>&nbsp;</td><td>
<p>Total number of integers per beagleUpdatePartials operation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2487a1c99f4214cd3a70468d0ccac55ca2eb262bbe41b1dbeff3e189d8de65b04"></a><!-- doxytag: member="BEAGLE_OP_NONE" ref="a2487a1c99f4214cd3a70468d0ccac55ca2eb262bbe41b1dbeff3e189d8de65b04" args="" -->BEAGLE_OP_NONE</em>&nbsp;</td><td>
<p>Specify no use for indexed buffer </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e61de870cc34893168a88fe6823dfce"></a><!-- doxytag: member="beagle.h::BeagleReturnCodes" ref="a9e61de870cc34893168a88fe6823dfce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="beagle_8h.html#a9e61de870cc34893168a88fe6823dfce">BeagleReturnCodes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error return codes. </p>
<p><a class="anchor" id="BEAGLE_RETURN_CODES"></a> This enumerates all possible BEAGLE return codes. Error codes are always negative. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea12aea4769c1be89867846782925b1cbe"></a><!-- doxytag: member="BEAGLE_SUCCESS" ref="a9e61de870cc34893168a88fe6823dfcea12aea4769c1be89867846782925b1cbe" args="" -->BEAGLE_SUCCESS</em>&nbsp;</td><td>
<p>Success </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea45c3bd53fdd83865d927202d0d582299"></a><!-- doxytag: member="BEAGLE_ERROR_GENERAL" ref="a9e61de870cc34893168a88fe6823dfcea45c3bd53fdd83865d927202d0d582299" args="" -->BEAGLE_ERROR_GENERAL</em>&nbsp;</td><td>
<p>Unspecified error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaf31bb198b162f0d9ed2e0490a475409d"></a><!-- doxytag: member="BEAGLE_ERROR_OUT_OF_MEMORY" ref="a9e61de870cc34893168a88fe6823dfceaf31bb198b162f0d9ed2e0490a475409d" args="" -->BEAGLE_ERROR_OUT_OF_MEMORY</em>&nbsp;</td><td>
<p>Not enough memory could be allocated </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea3fd3b3dc476c527884e6db3dc0d13738"></a><!-- doxytag: member="BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION" ref="a9e61de870cc34893168a88fe6823dfcea3fd3b3dc476c527884e6db3dc0d13738" args="" -->BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION</em>&nbsp;</td><td>
<p>Unspecified exception </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaba333086a5777117202ed0f16109157a"></a><!-- doxytag: member="BEAGLE_ERROR_UNINITIALIZED_INSTANCE" ref="a9e61de870cc34893168a88fe6823dfceaba333086a5777117202ed0f16109157a" args="" -->BEAGLE_ERROR_UNINITIALIZED_INSTANCE</em>&nbsp;</td><td>
<p>The instance index is out of range, or the instance has not been created </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea1118b576b6d5e1372f757ec246acd203"></a><!-- doxytag: member="BEAGLE_ERROR_OUT_OF_RANGE" ref="a9e61de870cc34893168a88fe6823dfcea1118b576b6d5e1372f757ec246acd203" args="" -->BEAGLE_ERROR_OUT_OF_RANGE</em>&nbsp;</td><td>
<p>One of the indices specified exceeded the range of the array </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfceaec9b03ad5cd754a99ed84e1755704beb"></a><!-- doxytag: member="BEAGLE_ERROR_NO_RESOURCE" ref="a9e61de870cc34893168a88fe6823dfceaec9b03ad5cd754a99ed84e1755704beb" args="" -->BEAGLE_ERROR_NO_RESOURCE</em>&nbsp;</td><td>
<p>No resource matches requirements </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea74be6f002aba021c7093dfe50b44f1ed"></a><!-- doxytag: member="BEAGLE_ERROR_NO_IMPLEMENTATION" ref="a9e61de870cc34893168a88fe6823dfcea74be6f002aba021c7093dfe50b44f1ed" args="" -->BEAGLE_ERROR_NO_IMPLEMENTATION</em>&nbsp;</td><td>
<p>No implementation matches requirements </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e61de870cc34893168a88fe6823dfcea267dcbe8ced105decc94598ba2be51ba"></a><!-- doxytag: member="BEAGLE_ERROR_FLOATING_POINT" ref="a9e61de870cc34893168a88fe6823dfcea267dcbe8ced105decc94598ba2be51ba" args="" -->BEAGLE_ERROR_FLOATING_POINT</em>&nbsp;</td><td>
<p>Floating-point range exceeded </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aeb435552108e272c036d89d9b725910b"></a><!-- doxytag: member="beagle.h::beagleAccumulateScaleFactors" ref="aeb435552108e272c036d89d9b725910b" args="(int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleAccumulateScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>scaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate scale factors. </p>
<p>This function adds (log) scale factors from a list of scaleBuffers to a cumulative scale buffer. It is used to calculate the marginal scaling at a specific node for each site.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">scaleIndices</td><td>List of scaleBuffers to add (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of scaleBuffers in list (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer to accumulate factors into (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2ea99215d252187479972517b4557d2"></a><!-- doxytag: member="beagle.h::beagleCalculateEdgeLogLikelihoods" ref="ac2ea99215d252187479972517b4557d2" args="(int instance, const int *parentBufferIndices, const int *childBufferIndices, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood, double *outSumFirstDerivative, double *outSumSecondDerivative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleCalculateEdgeLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>parentBufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>childBufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>probabilityIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>categoryWeightsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumLogLikelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumFirstDerivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumSecondDerivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate site log likelihoods and derivatives along an edge. </p>
<p>This function integrates a list of partials at a parent and child node with respect to a set of partials-weights and state frequencies to return the log likelihood and first and second derivative sums</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">parentBufferIndices</td><td>List of indices of parent partialsBuffers (input) </td></tr>
    <tr><td class="paramname">childBufferIndices</td><td>List of indices of child partialsBuffers (input) </td></tr>
    <tr><td class="paramname">probabilityIndices</td><td>List indices of transition probability matrices for this edge (input) </td></tr>
    <tr><td class="paramname">firstDerivativeIndices</td><td>List indices of first derivative matrices (input) </td></tr>
    <tr><td class="paramname">secondDerivativeIndices</td><td>List indices of second derivative matrices (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndices</td><td>List of weights to apply to each partialsBuffer (input) </td></tr>
    <tr><td class="paramname">stateFrequenciesIndices</td><td>List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">cumulativeScaleIndices</td><td>List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">count</td><td>Number of partialsBuffers (input) </td></tr>
    <tr><td class="paramname">outSumLogLikelihood</td><td>Pointer to destination for resulting log likelihood (output) </td></tr>
    <tr><td class="paramname">outSumFirstDerivative</td><td>Pointer to destination for resulting first derivative (output) </td></tr>
    <tr><td class="paramname">outSumSecondDerivative</td><td>Pointer to destination for resulting second derivative (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="adfb8c177b803aeef15daa9ed4c019e31"></a><!-- doxytag: member="beagle.h::beagleCalculateRootLogLikelihoods" ref="adfb8c177b803aeef15daa9ed4c019e31" args="(int instance, const int *bufferIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleCalculateRootLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>bufferIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>categoryWeightsIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSumLogLikelihood</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate site log likelihoods at a root node. </p>
<p>This function integrates a list of partials at a node with respect to a set of partials-weights and state frequencies to return the log likelihood sum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">bufferIndices</td><td>List of partialsBuffer indices to integrate (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndices</td><td>List of weights to apply to each partialsBuffer (input). There should be one categoryCount sized set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">stateFrequenciesIndices</td><td>List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">cumulativeScaleIndices</td><td>List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices </td></tr>
    <tr><td class="paramname">count</td><td>Number of partialsBuffer to integrate (input) </td></tr>
    <tr><td class="paramname">outSumLogLikelihood</td><td>Pointer to destination for resulting log likelihood (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="adc42e82d3c53cd203c1a51e7b35add90"></a><!-- doxytag: member="beagle.h::beagleCopyScaleFactors" ref="adc42e82d3c53cd203c1a51e7b35add90" args="(int instance, int destScalingIndex, int srcScalingIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleCopyScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destScalingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcScalingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy scale factors. </p>
<p>This function copies scale factors from one buffer to another.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">destScalingIndex</td><td>Destination scaleBuffer (input) </td></tr>
    <tr><td class="paramname">srcScalingIndex</td><td>Source scaleBuffer (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae86077bd2c778a0adddcb2c6aafd538e"></a><!-- doxytag: member="beagle.h::beagleCreateInstance" ref="ae86077bd2c778a0adddcb2c6aafd538e" args="(int tipCount, int partialsBufferCount, int compactBufferCount, int stateCount, int patternCount, int eigenBufferCount, int matrixBufferCount, int categoryCount, int scaleBufferCount, int *resourceList, int resourceCount, long preferenceFlags, long requirementFlags, BeagleInstanceDetails *returnInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleCreateInstance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partialsBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compactBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stateCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>categoryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleBufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resourceList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resourceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>preferenceFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>requirementFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_beagle_instance_details.html">BeagleInstanceDetails</a> *&#160;</td>
          <td class="paramname"><em>returnInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a single instance. </p>
<p>This function creates a single instance of the BEAGLE library and can be called multiple times to create multiple data partition instances each returning a unique identifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tipCount</td><td>Number of tip data elements (input) </td></tr>
    <tr><td class="paramname">partialsBufferCount</td><td>Number of partials buffers to create (input) </td></tr>
    <tr><td class="paramname">compactBufferCount</td><td>Number of compact state representation buffers to create (input) </td></tr>
    <tr><td class="paramname">stateCount</td><td>Number of states in the continuous-time Markov chain (input) </td></tr>
    <tr><td class="paramname">patternCount</td><td>Number of site patterns to be handled by the instance (input) </td></tr>
    <tr><td class="paramname">eigenBufferCount</td><td>Number of rate matrix eigen-decomposition, category weight, and state frequency buffers to allocate (input) </td></tr>
    <tr><td class="paramname">matrixBufferCount</td><td>Number of transition probability matrix buffers (input) </td></tr>
    <tr><td class="paramname">categoryCount</td><td>Number of rate categories (input) </td></tr>
    <tr><td class="paramname">scaleBufferCount</td><td>Number of scale buffers to create, ignored for auto scale or always scale (input) </td></tr>
    <tr><td class="paramname">resourceList</td><td>List of potential resources on which this instance is allowed (input, NULL implies no restriction) </td></tr>
    <tr><td class="paramname">resourceCount</td><td>Length of resourceList list (input) </td></tr>
    <tr><td class="paramname">preferenceFlags</td><td>Bit-flags indicating preferred implementation characteristics, see BeagleFlags (input) </td></tr>
    <tr><td class="paramname">requirementFlags</td><td>Bit-flags indicating required implementation characteristics, see BeagleFlags (input) </td></tr>
    <tr><td class="paramname">returnInfo</td><td>Pointer to return implementation and resource details</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the unique instance identifier (&lt;0 if failed, see <a class="el" href="beagle_8h.html#BEAGLE_RETURN_CODES">BeagleReturnCodes</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a7ef4ef3a5c331f66823d72eb9675d487"></a><!-- doxytag: member="beagle.h::beagleFinalize" ref="a7ef4ef3a5c331f66823d72eb9675d487" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleFinalize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize the library. </p>
<p>This function finalizes the library and releases all allocated memory. This function is automatically called under GNU C via __attribute__ ((destructor)).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a1a323eecf18b20ced4e787de47ab1693"></a><!-- doxytag: member="beagle.h::beagleFinalizeInstance" ref="a1a323eecf18b20ced4e787de47ab1693" args="(int instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleFinalizeInstance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize this instance. </p>
<p>This function finalizes the instance by releasing allocated memory</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5b920cd185992708f3c5b7b2a0f8c7"></a><!-- doxytag: member="beagle.h::beagleGetPartials" ref="a3c5b920cd185992708f3c5b7b2a0f8c7" args="(int instance, int bufferIndex, int scaleIndex, double *outPartials)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleGetPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get partials from an instance buffer. </p>
<p>This function copies an instance buffer into the array outPartials. The outPartials array should be stateCount * patternCount * categoryCount in length.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number from which to get partialsBuffer (input) </td></tr>
    <tr><td class="paramname">bufferIndex</td><td>Index of source partialsBuffer (input) </td></tr>
    <tr><td class="paramname">scaleIndex</td><td>Index of scaleBuffer to apply to partialsBuffer (input) </td></tr>
    <tr><td class="paramname">outPartials</td><td>Pointer to which to receive partialsBuffer (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a5608865bb1bac391da13758bcc04797f"></a><!-- doxytag: member="beagle.h::beagleGetResourceList" ref="a5608865bb1bac391da13758bcc04797f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_beagle_resource_list.html">BeagleResourceList</a>* beagleGetResourceList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get list of hardware resources. </p>
<p>This function returns a pointer to a <a class="el" href="struct_beagle_resource_list.html" title="List of hardware resources.">BeagleResourceList</a> struct, which includes a <a class="el" href="struct_beagle_resource.html" title="Description of a hardware resource.">BeagleResource</a> array describing the available hardware resources.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of hardware resources available to the library as a <a class="el" href="struct_beagle_resource_list.html" title="List of hardware resources.">BeagleResourceList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc5f5ef36423458ccde69f1c282fe653"></a><!-- doxytag: member="beagle.h::beagleGetSiteDerivatives" ref="acc5f5ef36423458ccde69f1c282fe653" args="(int instance, double *outFirstDerivatives, double *outSecondDerivatives)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleGetSiteDerivatives </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outFirstDerivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outSecondDerivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get site derivatives for last beagleCalculateEdgeLogLikelihoods call. </p>
<p>This function returns the derivatives for each site</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">outFirstDerivatives</td><td>Pointer to destination for resulting first derivatives (output) </td></tr>
    <tr><td class="paramname">outSecondDerivatives</td><td>Pointer to destination for resulting second derivatives (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ad54f99e2ed159883406b3f3c334122f5"></a><!-- doxytag: member="beagle.h::beagleGetSiteLogLikelihoods" ref="ad54f99e2ed159883406b3f3c334122f5" args="(int instance, double *outLogLikelihoods)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleGetSiteLogLikelihoods </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outLogLikelihoods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call. </p>
<p>This function returns the log likelihoods for each site</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">outLogLikelihoods</td><td>Pointer to destination for resulting log likelihoods (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ac36e6cccc8e36263a2bf4c3d4cfbe93d"></a><!-- doxytag: member="beagle.h::beagleGetTransitionMatrix" ref="ac36e6cccc8e36263a2bf4c3d4cfbe93d" args="(int instance, int matrixIndex, double *outMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleGetTransitionMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>outMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a finite-time transition probability matrix. </p>
<p>This function copies a finite-time transition matrix buffer into the array outMatrix. The outMatrix array should be of size stateCount * stateCount * categoryCount and will be filled with one matrix for each rate category.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndex</td><td>Index of matrix buffer (input) </td></tr>
    <tr><td class="paramname">outMatrix</td><td>Pointer to destination transition probability matrix (output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aac6b1cdf0de893bc0bad8f70c29f5b11"></a><!-- doxytag: member="beagle.h::beagleRemoveScaleFactors" ref="aac6b1cdf0de893bc0bad8f70c29f5b11" args="(int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleRemoveScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>scaleIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove scale factors. </p>
<p>This function removes (log) scale factors from a cumulative scale buffer. The scale factors to be removed are indicated in a list of scaleBuffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">scaleIndices</td><td>List of scaleBuffers to remove (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of scaleBuffers in list (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer containing accumulated factors (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec2b3b765ab40d575b3f6aeab68683d7"></a><!-- doxytag: member="beagle.h::beagleResetScaleFactors" ref="aec2b3b765ab40d575b3f6aeab68683d7" args="(int instance, int cumulativeScaleIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleResetScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset scalefactors. </p>
<p>This function resets a cumulative scale buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of cumulative scaleBuffer (input) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a507aa622001b43673de92e52b68d59db"></a><!-- doxytag: member="beagle.h::beagleSetCategoryRates" ref="a507aa622001b43673de92e52b68d59db" args="(int instance, const double *inCategoryRates)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetCategoryRates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inCategoryRates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set category rates. </p>
<p>This function sets the vector of category rates for an instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">inCategoryRates</td><td>Array containing categoryCount rate scalers (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a3f778a939fec8007c52957672b10e"></a><!-- doxytag: member="beagle.h::beagleSetCategoryWeights" ref="ac2a3f778a939fec8007c52957672b10e" args="(int instance, int categoryWeightsIndex, const double *inCategoryWeights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetCategoryWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>categoryWeightsIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inCategoryWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a category weights buffer. </p>
<p>This function copies a category weights array into an instance buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">categoryWeightsIndex</td><td>Index of category weights buffer (input) </td></tr>
    <tr><td class="paramname">inCategoryWeights</td><td>Category weights array (categoryCount) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a64c9222387b3e46bf0169f4cf7c5a713"></a><!-- doxytag: member="beagle.h::beagleSetEigenDecomposition" ref="a64c9222387b3e46bf0169f4cf7c5a713" args="(int instance, int eigenIndex, const double *inEigenVectors, const double *inInverseEigenVectors, const double *inEigenValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetEigenDecomposition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inEigenVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inInverseEigenVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inEigenValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an eigen-decomposition buffer. </p>
<p>This function copies an eigen-decomposition into an instance buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">eigenIndex</td><td>Index of eigen-decomposition buffer (input) </td></tr>
    <tr><td class="paramname">inEigenVectors</td><td>Flattened matrix (stateCount x stateCount) of eigen-vectors (input) </td></tr>
    <tr><td class="paramname">inInverseEigenVectors</td><td>Flattened matrix (stateCount x stateCount) of inverse-eigen- vectors (input) </td></tr>
    <tr><td class="paramname">inEigenValues</td><td>Vector of eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ad4ee216eb5186b31db462aa199a06c6a"></a><!-- doxytag: member="beagle.h::beagleSetPartials" ref="ad4ee216eb5186b31db462aa199a06c6a" args="(int instance, int bufferIndex, const double *inPartials)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an instance partials buffer. </p>
<p>This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount * categoryCount in length.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number in which to set a partialsBuffer (input) </td></tr>
    <tr><td class="paramname">bufferIndex</td><td>Index of destination partialsBuffer (input) </td></tr>
    <tr><td class="paramname">inPartials</td><td>Pointer to partials values to set (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a254ee344c0b6e912b4105dddbb377bd8"></a><!-- doxytag: member="beagle.h::beagleSetPatternWeights" ref="a254ee344c0b6e912b4105dddbb377bd8" args="(int instance, const double *inPatternWeights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetPatternWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPatternWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set pattern weights. </p>
<p>This function sets the vector of pattern weights for an instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">inPatternWeights</td><td>Array containing patternCount weights (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aabbd1b0c83b7abddc4cdbc266cab3ddd"></a><!-- doxytag: member="beagle.h::beagleSetStateFrequencies" ref="aabbd1b0c83b7abddc4cdbc266cab3ddd" args="(int instance, int stateFrequenciesIndex, const double *inStateFrequencies)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetStateFrequencies </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stateFrequenciesIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inStateFrequencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a state frequency buffer. </p>
<p>This function copies a state frequency array into an instance buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">stateFrequenciesIndex</td><td>Index of state frequencies buffer (input) </td></tr>
    <tr><td class="paramname">inStateFrequencies</td><td>State frequencies array (stateCount) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ad11209a76797cec7ee83d2be0cf3f6f7"></a><!-- doxytag: member="beagle.h::beagleSetTipPartials" ref="ad11209a76797cec7ee83d2be0cf3f6f7" args="(int instance, int tipIndex, const double *inPartials)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetTipPartials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inPartials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an instance partials buffer for tip node. </p>
<p>This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount in length. For most applications this will be used to set the partial likelihoods for the observed states. Internally, the partials will be copied categoryCount times.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number in which to set a partialsBuffer (input) </td></tr>
    <tr><td class="paramname">tipIndex</td><td>Index of destination partialsBuffer (input) </td></tr>
    <tr><td class="paramname">inPartials</td><td>Pointer to partials values to set (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a740b58891b46401309f9b524842c5073"></a><!-- doxytag: member="beagle.h::beagleSetTipStates" ref="a740b58891b46401309f9b524842c5073" args="(int instance, int tipIndex, const int *inStates)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetTipStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tipIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>inStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the compact state representation for tip node. </p>
<p>This function copies a compact state representation into an instance buffer. Compact state representation is an array of states: 0 to stateCount - 1 (missing = stateCount). The inStates array should be patternCount in length (replication across categoryCount is not required).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">tipIndex</td><td>Index of destination compactBuffer (input) </td></tr>
    <tr><td class="paramname">inStates</td><td>Pointer to compact states (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ac13c2302faf8fca8dc5bbbde52a25c3a"></a><!-- doxytag: member="beagle.h::beagleSetTransitionMatrices" ref="ac13c2302faf8fca8dc5bbbde52a25c3a" args="(int instance, const int *matrixIndices, const double *inMatrices, const double *paddedValues, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetTransitionMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>matrixIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inMatrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>paddedValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set multiple transition matrices. </p>
<p>This function copies multiple transition matrices into matrix buffers. This function is used when the application wishes to explicitly set the transition matrices rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrices array should be of size stateCount * stateCount * categoryCount * count.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndices</td><td>Indices of matrix buffers (input) </td></tr>
    <tr><td class="paramname">inMatrices</td><td>Pointer to source transition matrices (input) </td></tr>
    <tr><td class="paramname">paddedValues</td><td>Values to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input) </td></tr>
    <tr><td class="paramname">count</td><td>Number of transition matrices (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c2e40b1be12673a284bc00174e523f"></a><!-- doxytag: member="beagle.h::beagleSetTransitionMatrix" ref="ab6c2e40b1be12673a284bc00174e523f" args="(int instance, int matrixIndex, const double *inMatrix, double paddedValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleSetTransitionMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>matrixIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>inMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>paddedValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a finite-time transition probability matrix. </p>
<p>This function copies a finite-time transition probability matrix into a matrix buffer. This function is used when the application wishes to explicitly set the transition probability matrix rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrix array should be of size stateCount * stateCount * categoryCount and will contain one matrix for each rate category.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">matrixIndex</td><td>Index of matrix buffer (input) </td></tr>
    <tr><td class="paramname">inMatrix</td><td>Pointer to source transition probability matrix (input) </td></tr>
    <tr><td class="paramname">paddedValue</td><td>Value to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="a60a7d64445811dd8075d3f728fbd1ca6"></a><!-- doxytag: member="beagle.h::beagleUpdatePartials" ref="a60a7d64445811dd8075d3f728fbd1ca6" args="(const int instance, const BeagleOperation *operations, int operationCount, int cumulativeScaleIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleUpdatePartials </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_beagle_operation.html">BeagleOperation</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cumulativeScaleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate or queue for calculation partials using a list of operations. </p>
<p>This function either calculates or queues for calculation a list partials. Implementations supporting ASYNCH may queue these calculations while other implementations perform these operations immediately and in order.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">operations</td><td><a class="el" href="struct_beagle_operation.html" title="A list of integer indices which specify a partial likelihoods operation.">BeagleOperation</a> list specifying operations (input) </td></tr>
    <tr><td class="paramname">operationCount</td><td>Number of operations (input) </td></tr>
    <tr><td class="paramname">cumulativeScaleIndex</td><td>Index number of scaleBuffer to store accumulated factors (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="afd6da9bba8e5a0cc10bc83a5ff08f61c"></a><!-- doxytag: member="beagle.h::beagleUpdateTransitionMatrices" ref="afd6da9bba8e5a0cc10bc83a5ff08f61c" args="(int instance, int eigenIndex, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const double *edgeLengths, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleUpdateTransitionMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eigenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>probabilityIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondDerivativeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>edgeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate a list of transition probability matrices. </p>
<p>This function calculates a list of transition probabilities matrices and their first and second derivatives (if requested).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">eigenIndex</td><td>Index of eigen-decomposition buffer (input) </td></tr>
    <tr><td class="paramname">probabilityIndices</td><td>List of indices of transition probability matrices to update (input) </td></tr>
    <tr><td class="paramname">firstDerivativeIndices</td><td>List of indices of first derivative matrices to update (input, NULL implies no calculation) </td></tr>
    <tr><td class="paramname">secondDerivativeIndices</td><td>List of indices of second derivative matrices to update (input, NULL implies no calculation) </td></tr>
    <tr><td class="paramname">edgeLengths</td><td>List of edge lengths with which to perform calculations (input) </td></tr>
    <tr><td class="paramname">count</td><td>Length of lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
<a class="anchor" id="aec7540bfa4f340a16294c4a1306129b9"></a><!-- doxytag: member="beagle.h::beagleWaitForPartials" ref="aec7540bfa4f340a16294c4a1306129b9" args="(const int instance, const int *destinationPartials, int destinationPartialsCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beagleWaitForPartials </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinationPartials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationPartialsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block until all calculations that write to the specified partials have completed. </p>
<p>This function is optional and only has to be called by clients that "recycle" partials.</p>
<p>If used, this function must be called after an beagleUpdatePartials call and must refer to indices of "destinationPartials" that were used in a previous beagleUpdatePartials call. The library will block until those partials have been calculated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number (input) </td></tr>
    <tr><td class="paramname">destinationPartials</td><td>List of the indices of destinationPartials that must be calculated before the function returns </td></tr>
    <tr><td class="paramname">destinationPartialsCount</td><td>Number of destinationPartials (input)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 16 2011 17:05:31 for BEAGLE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
